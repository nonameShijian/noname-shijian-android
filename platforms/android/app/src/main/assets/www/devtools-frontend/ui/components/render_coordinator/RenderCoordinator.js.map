{"version":3,"file":"RenderCoordinator.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/render_coordinator/RenderCoordinator.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AA2C7B,MAAM,OAAO,gCAAiC,SAAQ,KAAK;IACzD,MAAM,CAAU,SAAS,GAAG,kBAAkB,CAAC;IAC/C;QACE,KAAK,CAAC,gCAAgC,CAAC,SAAS,CAAC,CAAC;IACpD,CAAC;;AAGH,MAAM,OAAO,8BAA+B,SAAQ,KAAK;IACvD,MAAM,CAAU,SAAS,GAAG,UAAU,CAAC;IACvC;QACE,KAAK,CAAC,8BAA8B,CAAC,SAAS,CAAC,CAAC;IAClD,CAAC;;AAGH,IAAI,yBAA4C,CAAC;AAEjD,MAAM,YAAY,GAAG,cAAc,CAAC;AACpC,MAAM,aAAa,GAAG,eAAe,CAAC;AACtC,MAAM,cAAc,GAAG,gBAAgB,CAAC;AACxC,MAAM,gBAAgB,GAAG,IAAI,CAAC;AAE9B,8DAA8D;AAC7D,UAAkB,CAAC,mCAAmC,GAAG;IACxD,OAAO,iBAAiB,CAAC,kBAAkB,EAAE,CAAC;AAChD,CAAC,CAAC;AAEF,MAAM,OAAO,iBAAkB,SAAQ,WAAW;IAChD,MAAM,CAAC,QAAQ,CAAC,EAAC,QAAQ,GAAG,KAAK,EAAC,GAAG,EAAE;QACrC,IAAI,CAAC,yBAAyB,IAAI,QAAQ,EAAE;YAC1C,yBAAyB,GAAG,IAAI,iBAAiB,EAAE,CAAC;SACrD;QAED,OAAO,yBAAyB,CAAC;IACnC,CAAC;IAED,MAAM,CAAC,kBAAkB;QACvB,IAAI,CAAC,yBAAyB,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;SAC1D;QAED,OAAO,yBAAyB,CAAC,kBAAkB,EAAE,CAAC;IACxD,CAAC;IAED,8DAA8D;IAC9D,+EAA+E;IAC/E,OAAO,GAAG,KAAK,CAAC;IAChB,kBAAkB,GAAG,GAAG,CAAC;IAEzB,qDAAqD;IACrD,6DAA6D;IAC7D,gBAAgB,GAAG,IAAI,CAAC;IAEf,YAAY,GAA0B,EAAE,CAAC;IAEzC,kBAAkB,GAAuB,EAAE,CAAC;IACrD,gBAAgB,GAAG,CAAC,CAAC;IAErB,kBAAkB;QAChB,OAAO,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC;IACxC,CAAC;IAED,IAAI,CAAC,OAAgC;QACnC,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,EAAE;YACjE,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;YACpC,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SAC1B;QACD,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE,EAAE,EAAC,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC;IAC1G,CAAC;IAID,KAAK,CAAC,IAAI,CAAoB,eAA2C,EAAE,QAA8B;QAEvG,IAAI,OAAO,eAAe,KAAK,QAAQ,EAAE;YACvC,IAAI,CAAC,QAAQ,EAAE;gBACb,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;aAC3D;YACD,OAAO,IAAI,CAAC,eAAe,CAAI,QAAQ,4BAAe,eAAe,CAAC,CAAC;SACxE;QAED,OAAO,IAAI,CAAC,eAAe,CAAI,eAAe,4BAAe,YAAY,CAAC,CAAC;IAC7E,CAAC;IAID,KAAK,CAAC,KAAK,CAAoB,eAA2C,EAAE,QAA8B;QAExG,IAAI,OAAO,eAAe,KAAK,QAAQ,EAAE;YACvC,IAAI,CAAC,QAAQ,EAAE;gBACb,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;aAC5D;YACD,OAAO,IAAI,CAAC,eAAe,CAAI,QAAQ,8BAAgB,eAAe,CAAC,CAAC;SACzE;QAED,OAAO,IAAI,CAAC,eAAe,CAAI,eAAe,8BAAgB,aAAa,CAAC,CAAC;IAC/E,CAAC;IAED,WAAW;QACT,MAAM,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC;QACpC,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;QAC7B,OAAO,IAAI,CAAC;IACd,CAAC;IAUD,KAAK,CAAC,MAAM,CAAoB,eAA2C,EAAE,QAA8B;QAEzG,IAAI,OAAO,eAAe,KAAK,QAAQ,EAAE;YACvC,IAAI,CAAC,QAAQ,EAAE;gBACb,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;aAC7D;YACD,OAAO,IAAI,CAAC,eAAe,CAAI,QAAQ,4BAAe,eAAe,CAAC,CAAC;SACxE;QAED,OAAO,IAAI,CAAC,eAAe,CAAI,eAAe,4BAAe,cAAc,CAAC,CAAC;IAC/E,CAAC;IAED,eAAe,CAAc,QAA6B,EAAE,MAAc,EAAE,KAAa;QACvF,MAAM,OAAO,GAAG,CAAC,CAAC,YAAY,EAAE,aAAa,EAAE,cAAc,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC/E,KAAK,GAAG,GAAG,MAAM,6BAAgB,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,KAAK,KAAK,EAAE,CAAC;QACrE,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,KAAK,CAAC,EAAE;YACxC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;gBAC3B,OAAO,EAAE,EAAE;gBACX,OAAO,EAAE,EAAE;aACZ,CAAC,CAAC;SACJ;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC;QACzC,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;SACvC;QAED,IAAI,SAAS,GAAG,IAAI,CAAC;QACrB,QAAQ,MAAM,EAAE;YACd;gBACE,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC;gBAC1B,MAAM;YAER;gBACE,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC;gBAC1B,MAAM;YAER;gBACE,MAAM,IAAI,KAAK,CAAC,mBAAmB,MAAM,EAAE,CAAC,CAAC;SAChD;QAED,IAAI,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QACvE,IAAI,CAAC,QAAQ,EAAE;YACb,MAAM,WAAW,GAAG,EAAC,KAAK,EAAa,CAAC;YACxC,WAAW,CAAC,OAAO,GAAG,CAAC,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACrC,WAAW,CAAC,OAAO,GAAG,OAAO,CAAC;gBAC9B,WAAW,CAAC,MAAM,GAAG,MAAM,CAAC;YAC9B,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,CAAC;YAC5D,QAAQ,GAAG,WAAW,CAAC;YACvB,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SAC1B;QACD,yEAAyE;QACzE,yFAAyF;QACzF,2CAA2C;QAC3C,QAAQ,CAAC,OAAO,GAAG,QAAQ,CAAC;QAE5B,IAAI,CAAC,aAAa,EAAE,CAAC;QACrB,OAAO,QAAQ,CAAC,OAAqB,CAAC;IACxC,CAAC;IAED,aAAa;QACX,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,KAAK,CAAC,CAAC;QACrD,IAAI,gBAAgB,EAAE;YACpB,OAAO;SACR;QAED,IAAI,CAAC,gBAAgB,GAAG,qBAAqB,CAAC,KAAK,IAAI,EAAE;YACvD,MAAM,gBAAgB,GAAG,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC;YAC5D,IAAI,CAAC,gBAAgB,EAAE;gBACrB,0DAA0D;gBAC1D,+DAA+D;gBAC/D,6DAA6D;gBAC7D,gEAAgE;gBAChE,oEAAoE;gBACpE,IAAI,CAAC,aAAa,CAAC,IAAI,gCAAgC,EAAE,CAAC,CAAC;gBAC3D,MAAM,CAAC,aAAa,CAAC,IAAI,gCAAgC,EAAE,CAAC,CAAC;gBAE7D,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;gBACpC,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;gBAC1B,OAAO;aACR;YAED,IAAI,CAAC,aAAa,CAAC,IAAI,8BAA8B,EAAE,CAAC,CAAC;YACzD,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;YAElC,MAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;YAC9C,IAAI,CAAC,KAAK,EAAE;gBACV,OAAO;aACR;YAED,4CAA4C;YAC5C,uBAAuB;YACvB,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,OAAO,EAAE;gBAClC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACjC,MAAM,CAAC,OAAO,EAAE,CAAC;aAClB;YAED,gCAAgC;YAChC,IAAI;gBACF,MAAM,OAAO,CAAC,IAAI,CAAC;oBACjB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;oBAC9C,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE;wBACxB,MAAM,CAAC,UAAU,CACb,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,qBAAqB,gBAAgB,wBAAwB,CAAC,CAAC,EACtF,gBAAgB,CAAC,CAAC;oBACxB,CAAC,CAAC;iBACH,CAAC,CAAC;aACJ;YAAC,OAAO,GAAG,EAAE;gBACZ,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;aACrC;YAED,sCAAsC;YACtC,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,OAAO,EAAE;gBAClC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACjC,MAAM,CAAC,OAAO,EAAE,CAAC;aAClB;YAED,qCAAqC;YACrC,IAAI;gBACF,MAAM,OAAO,CAAC,IAAI,CAAC;oBACjB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;oBAC9C,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE;wBACxB,MAAM,CAAC,UAAU,CACb,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,qBAAqB,gBAAgB,wBAAwB,CAAC,CAAC,EACtF,gBAAgB,CAAC,CAAC;oBACxB,CAAC,CAAC;iBACH,CAAC,CAAC;aACJ;YAAC,OAAO,GAAG,EAAE;gBACZ,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;aACrC;YAED,mDAAmD;YACnD,4DAA4D;YAC5D,oBAAoB;YACpB,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;YAC1B,IAAI,CAAC,aAAa,EAAE,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,UAAU,CAAC,QAAoB,EAAE,KAAY;QAC3C,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;YAC9B,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACvB;IACH,CAAC;IAED,aAAa;QACX,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;QAC1B,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3C,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;YACtC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SACvC;IACH,CAAC;IAED,aAAa,CAAC,KAAuB;QACnC,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,KAAK,EAAE;YAC3B,OAAO;SACR;QACD,MAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;QAClH,IAAI,SAAS,IAAI,IAAI,CAAC,gBAAgB,EAAE;YACtC,OAAO;SACR;QAED,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,WAAW,CAAC,GAAG,EAAE,EAAE,KAAK,EAAC,CAAC,CAAC;QAEzD,gCAAgC;QAChC,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,IAAI,CAAC,kBAAkB,EAAE;YACzD,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;SAC3B;IACH,CAAC;CACF","sourcesContent":["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Components don't orchestrate their DOM updates in a wider context\n * (i.e. the host frame's document), which leads to interleaved reading\n * and writing of layout-centric values, e.g. clientHeight, scrollTop etc.\n *\n * This helper to ensure that we do reads, writes, and scrolls at the\n * correct point in the frame lifecycle. It groups reads to the start of a\n * frame, where we can assume layout-centric values are available on the\n * basis of the last completed frame, and then it runs all writes\n * afterwards. In the event that a read / write / scroll callback contains\n * calls for more read / write / scroll calls, such calls will be scheduled\n * for the next available frame.\n */\n\ninterface CoordinatorCallback {\n  (): unknown;\n}\n\ninterface WorkItem {\n  trigger: () => void;\n  cancel: (_: Error) => void;\n  promise: Promise<unknown>;\n  handler: CoordinatorCallback;\n  label: string;\n}\n\ninterface CoordinatorFrame {\n  readers: WorkItem[];\n  writers: WorkItem[];\n}\n\ninterface CoordinatorLogEntry {\n  time: number;\n  value: string;\n}\n\nconst enum ACTION {\n  READ = 'read',\n  WRITE = 'write',\n}\n\nexport class RenderCoordinatorQueueEmptyEvent extends Event {\n  static readonly eventName = 'renderqueueempty';\n  constructor() {\n    super(RenderCoordinatorQueueEmptyEvent.eventName);\n  }\n}\n\nexport class RenderCoordinatorNewFrameEvent extends Event {\n  static readonly eventName = 'newframe';\n  constructor() {\n    super(RenderCoordinatorNewFrameEvent.eventName);\n  }\n}\n\nlet renderCoordinatorInstance: RenderCoordinator;\n\nconst UNNAMED_READ = 'Unnamed read';\nconst UNNAMED_WRITE = 'Unnamed write';\nconst UNNAMED_SCROLL = 'Unnamed scroll';\nconst DEADLOCK_TIMEOUT = 1500;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).__getRenderCoordinatorPendingFrames = function(): number {\n  return RenderCoordinator.pendingFramesCount();\n};\n\nexport class RenderCoordinator extends EventTarget {\n  static instance({forceNew = false} = {}): RenderCoordinator {\n    if (!renderCoordinatorInstance || forceNew) {\n      renderCoordinatorInstance = new RenderCoordinator();\n    }\n\n    return renderCoordinatorInstance;\n  }\n\n  static pendingFramesCount(): number {\n    if (!renderCoordinatorInstance) {\n      throw new Error('No render coordinator instance found.');\n    }\n\n    return renderCoordinatorInstance.pendingFramesCount();\n  }\n\n  // Toggle on to start tracking. You must call takeRecords() to\n  // obtain the records. Please note: records are limited by maxRecordSize below.\n  observe = false;\n  recordStorageLimit = 100;\n\n  // If true, only log activity with an explicit label.\n  // This does not affect logging frames or queue empty events.\n  observeOnlyNamed = true;\n\n  readonly #logInternal: CoordinatorLogEntry[] = [];\n\n  readonly #pendingWorkFrames: CoordinatorFrame[] = [];\n  #scheduledWorkId = 0;\n\n  pendingFramesCount(): number {\n    return this.#pendingWorkFrames.length;\n  }\n\n  done(options?: {waitForWork: boolean}): Promise<void> {\n    if (this.#pendingWorkFrames.length === 0 && !options?.waitForWork) {\n      this.#logIfEnabled('[Queue empty]');\n      return Promise.resolve();\n    }\n    return new Promise(resolve => this.addEventListener('renderqueueempty', () => resolve(), {once: true}));\n  }\n\n  async read<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async read<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async read<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Read called with label but no callback');\n      }\n      return this.#enqueueHandler<T>(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.#enqueueHandler<T>(labelOrCallback, ACTION.READ, UNNAMED_READ);\n  }\n\n  async write<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async write<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async write<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Write called with label but no callback');\n      }\n      return this.#enqueueHandler<T>(callback, ACTION.WRITE, labelOrCallback);\n    }\n\n    return this.#enqueueHandler<T>(labelOrCallback, ACTION.WRITE, UNNAMED_WRITE);\n  }\n\n  takeRecords(): CoordinatorLogEntry[] {\n    const logs = [...this.#logInternal];\n    this.#logInternal.length = 0;\n    return logs;\n  }\n\n  /**\n   * We offer a convenience function for scroll-based activity, but often triggering a scroll\n   * requires a layout pass, thus it is better handled as a read activity, i.e. we wait until\n   * the layout-triggering work has been completed then it should be possible to scroll without\n   * first forcing layout.\n   */\n  async scroll<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async scroll<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async scroll<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Scroll called with label but no callback');\n      }\n      return this.#enqueueHandler<T>(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.#enqueueHandler<T>(labelOrCallback, ACTION.READ, UNNAMED_SCROLL);\n  }\n\n  #enqueueHandler<T = unknown>(callback: CoordinatorCallback, action: ACTION, label: string): Promise<T> {\n    const hasName = ![UNNAMED_READ, UNNAMED_WRITE, UNNAMED_SCROLL].includes(label);\n    label = `${action === ACTION.READ ? '[Read]' : '[Write]'}: ${label}`;\n    if (this.#pendingWorkFrames.length === 0) {\n      this.#pendingWorkFrames.push({\n        readers: [],\n        writers: [],\n      });\n    }\n\n    const frame = this.#pendingWorkFrames[0];\n    if (!frame) {\n      throw new Error('No frame available');\n    }\n\n    let workItems = null;\n    switch (action) {\n      case ACTION.READ:\n        workItems = frame.readers;\n        break;\n\n      case ACTION.WRITE:\n        workItems = frame.writers;\n        break;\n\n      default:\n        throw new Error(`Unknown action: ${action}`);\n    }\n\n    let workItem = hasName ? workItems.find(w => w.label === label) : null;\n    if (!workItem) {\n      const newWorkItem = {label} as WorkItem;\n      newWorkItem.promise = (new Promise<void>((resolve, reject) => {\n                              newWorkItem.trigger = resolve;\n                              newWorkItem.cancel = reject;\n                            })).then(() => newWorkItem.handler());\n      workItem = newWorkItem;\n      workItems.push(workItem);\n    }\n    // We are always using the latest handler, so that we don't end up with a\n    // stale results. We are reusing the promise to avoid blocking the first invocation, when\n    // it is being \"overridden\" by another one.\n    workItem.handler = callback;\n\n    this.#scheduleWork();\n    return workItem.promise as Promise<T>;\n  }\n\n  #scheduleWork(): void {\n    const hasScheduledWork = this.#scheduledWorkId !== 0;\n    if (hasScheduledWork) {\n      return;\n    }\n\n    this.#scheduledWorkId = requestAnimationFrame(async () => {\n      const hasPendingFrames = this.#pendingWorkFrames.length > 0;\n      if (!hasPendingFrames) {\n        // No pending frames means all pending work has completed.\n        // The events dispatched below are mostly for testing contexts.\n        // The first is for cases where we have a direct reference to\n        // the render coordinator. The second is for other test contexts\n        // where we don't, and instead we listen for an event on the window.\n        this.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n        window.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n\n        this.#logIfEnabled('[Queue empty]');\n        this.#scheduledWorkId = 0;\n        return;\n      }\n\n      this.dispatchEvent(new RenderCoordinatorNewFrameEvent());\n      this.#logIfEnabled('[New frame]');\n\n      const frame = this.#pendingWorkFrames.shift();\n      if (!frame) {\n        return;\n      }\n\n      // Start with all the readers and allow them\n      // to proceed together.\n      for (const reader of frame.readers) {\n        this.#logIfEnabled(reader.label);\n        reader.trigger();\n      }\n\n      // Wait for them all to be done.\n      try {\n        await Promise.race([\n          Promise.all(frame.readers.map(r => r.promise)),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Readers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(frame.readers, err);\n      }\n\n      // Next do all the writers as a block.\n      for (const writer of frame.writers) {\n        this.#logIfEnabled(writer.label);\n        writer.trigger();\n      }\n\n      // And wait for them to be done, too.\n      try {\n        await Promise.race([\n          Promise.all(frame.writers.map(w => w.promise)),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Writers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(frame.writers, err);\n      }\n\n      // Since there may have been more work requested in\n      // the callback of a reader / writer, we attempt to schedule\n      // it at this point.\n      this.#scheduledWorkId = 0;\n      this.#scheduleWork();\n    });\n  }\n\n  #rejectAll(handlers: WorkItem[], error: Error): void {\n    for (const handler of handlers) {\n      handler.cancel(error);\n    }\n  }\n\n  cancelPending(): void {\n    const error = new Error();\n    for (const frame of this.#pendingWorkFrames) {\n      this.#rejectAll(frame.readers, error);\n      this.#rejectAll(frame.writers, error);\n    }\n  }\n\n  #logIfEnabled(value: string|undefined): void {\n    if (!this.observe || !value) {\n      return;\n    }\n    const hasNoName = value.endsWith(UNNAMED_READ) || value.endsWith(UNNAMED_WRITE) || value.endsWith(UNNAMED_SCROLL);\n    if (hasNoName && this.observeOnlyNamed) {\n      return;\n    }\n\n    this.#logInternal.push({time: performance.now(), value});\n\n    // Keep the log at the log size.\n    while (this.#logInternal.length > this.recordStorageLimit) {\n      this.#logInternal.shift();\n    }\n  }\n}\n"]}