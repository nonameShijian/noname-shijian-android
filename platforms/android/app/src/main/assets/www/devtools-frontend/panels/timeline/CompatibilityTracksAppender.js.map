{"version":3,"file":"CompatibilityTracksAppender.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/CompatibilityTracksAppender.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as TraceEngine from '../../models/trace/trace.js';\nimport type * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as TimelineModel from '../../models/timeline_model/timeline_model.js';\nimport * as Common from '../../core/common/common.js';\nimport * as ThemeSupport from '../../ui/legacy/theme_support/theme_support.js';\n\nimport {\n  type TimelineFlameChartEntry,\n  EntryType,\n  InstantEventVisibleDurationMs,\n} from './TimelineFlameChartDataProvider.js';\nimport {TimingsTrackAppender} from './TimingsTrackAppender.js';\nimport {InteractionsTrackAppender} from './InteractionsTrackAppender.js';\nimport {GPUTrackAppender} from './GPUTrackAppender.js';\nimport {LayoutShiftsTrackAppender} from './LayoutShiftsTrackAppender.js';\nimport {getEventLevel} from './AppenderUtils.js';\nimport {TimelineUIUtils} from './TimelineUIUtils.js';\n\nexport type HighlightedEntryInfo = {\n  title: string,\n  formattedTime: string,\n  warning?: string,\n};\n\n/**\n * Track appenders add the data of each track into the timeline flame\n * chart. Each track appender also implements functions tha allow the\n * canvas renderer to gather more information about an event in a track,\n * like its display name or color.\n *\n * At the moment, tracks in the timeline flame chart are appended in\n * two locations: in the TimelineFlameChartDataProvider and in the track\n * appenders exported by this module. As part of the work to use a new\n * trace parsing engine, a track appender will be defined with this API\n * for each of the tracks in the timeline. With this implementation in\n * place its counterpart in the TimelineFlameChartDataProvider can be\n * removed. This processes of doing this for a track is referred to as\n * \"migrating the track\" to the new system.\n *\n * The migration implementation will result beneficial among other\n * things because the complexity of rendering the details of each track\n * is distributed among multiple standalone modules.\n * Read more at go/rpp-flamechart-arch\n */\n\nexport interface TrackAppender {\n  /**\n   * The unique name given to the track appender.\n   */\n  appenderName: TrackAppenderName;\n\n  /**\n   * Appends into the flame chart data the data corresponding to a track.\n   * @param level the horizontal level of the flame chart events where the\n   * track's events will start being appended.\n   * @param expanded wether the track should be rendered expanded.\n   * @returns the first available level to append more data after having\n   * appended the track's events.\n   */\n  appendTrackAtLevel(level: number, expanded?: boolean): number;\n  /**\n   * Returns the color an event is shown with in the timeline.\n   */\n  colorForEvent(event: TraceEngine.Types.TraceEvents.TraceEventData): string;\n  /**\n   * Returns the title an event is shown with in the timeline.\n   */\n  titleForEvent(event: TraceEngine.Types.TraceEvents.TraceEventData): string;\n  /**\n   * Returns the info shown when an event in the timeline is hovered.\n   */\n  highlightedEntryInfo(event: TraceEngine.Types.TraceEvents.TraceEventData): HighlightedEntryInfo;\n}\n\nexport const TrackNames = ['Timings', 'Interactions', 'GPU', 'LayoutShifts'] as const;\nexport type TrackAppenderName = typeof TrackNames[number];\n\nexport class CompatibilityTracksAppender {\n  #trackForLevel = new Map<number, TrackAppender>();\n  #trackForGroup = new Map<PerfUI.FlameChart.Group, TrackAppender>();\n  #eventsForTrack = new Map<TrackAppenderName, TraceEngine.Types.TraceEvents.TraceEventData[]>();\n  #trackEventsForTreeview = new Map<TrackAppenderName, TraceEngine.Types.TraceEvents.TraceEventData[]>();\n  #flameChartData: PerfUI.FlameChart.FlameChartTimelineData;\n  #traceParsedData: TraceEngine.Handlers.Migration.PartialTraceData;\n  #entryData: TimelineFlameChartEntry[];\n  #colorGenerator: Common.Color.Generator;\n  #indexForEvent = new WeakMap<TraceEngine.Types.TraceEvents.TraceEventData, number>();\n  #allTrackAppenders: TrackAppender[] = [];\n  #visibleTrackNames: Set<TrackAppenderName> = new Set([...TrackNames]);\n\n  // TODO(crbug.com/1416533)\n  // These are used only for compatibility with the legacy flame chart\n  // architecture of the panel. Once all tracks have been migrated to\n  // use the new engine and flame chart architecture, the reference can\n  // be removed.\n  #legacyTimelineModel: TimelineModel.TimelineModel.TimelineModelImpl;\n  #legacyEntryTypeByLevel: EntryType[];\n  #timingsTrackAppender: TimingsTrackAppender;\n  #interactionsTrackAppender: InteractionsTrackAppender;\n  #gpuTrackAppender: GPUTrackAppender;\n  #layoutShiftsTrackAppender: LayoutShiftsTrackAppender;\n\n  /**\n   * @param flameChartData the data used by the flame chart renderer on\n   * which the track data will be appended.\n   * @param traceParsedData the trace parsing engines output.\n   * @param entryData the array containing all event to be rendered in\n   * the flamechart.\n   * @param legacyEntryTypeByLevel an array containing the type of\n   * each entry in the entryData array. Indexed by the position the\n   * corresponding entry occupies in the entryData array. This reference\n   * is needed only for compatibility with the legacy flamechart\n   * architecture and should be removed once all tracks use the new\n   * system.\n   */\n  constructor(\n      flameChartData: PerfUI.FlameChart.FlameChartTimelineData,\n      traceParsedData: TraceEngine.Handlers.Migration.PartialTraceData, entryData: TimelineFlameChartEntry[],\n      legacyEntryTypeByLevel: EntryType[], legacyTimelineModel: TimelineModel.TimelineModel.TimelineModelImpl) {\n    this.#flameChartData = flameChartData;\n    this.#traceParsedData = traceParsedData;\n    this.#entryData = entryData;\n    this.#colorGenerator = new Common.Color.Generator(\n        /* hueSpace= */ {min: 30, max: 55, count: undefined},\n        /* satSpace= */ {min: 70, max: 100, count: 6},\n        /* lightnessSpace= */ 50,\n        /* alphaSpace= */ 0.7);\n    this.#legacyEntryTypeByLevel = legacyEntryTypeByLevel;\n    this.#legacyTimelineModel = legacyTimelineModel;\n\n    this.#timingsTrackAppender =\n        new TimingsTrackAppender(this, this.#flameChartData, this.#traceParsedData, this.#colorGenerator);\n    this.#allTrackAppenders.push(this.#timingsTrackAppender);\n\n    this.#interactionsTrackAppender =\n        new InteractionsTrackAppender(this, this.#flameChartData, this.#traceParsedData, this.#colorGenerator);\n    this.#allTrackAppenders.push(this.#interactionsTrackAppender);\n\n    this.#gpuTrackAppender = new GPUTrackAppender(this, this.#traceParsedData);\n    this.#allTrackAppenders.push(this.#gpuTrackAppender);\n\n    // Layout Shifts track in OPP was called the \"Experience\" track even though\n    // all it shows are layout shifts.\n    this.#layoutShiftsTrackAppender = new LayoutShiftsTrackAppender(this, this.#flameChartData, this.#traceParsedData);\n    this.#allTrackAppenders.push(this.#layoutShiftsTrackAppender);\n\n    ThemeSupport.ThemeSupport.instance().addEventListener(ThemeSupport.ThemeChangeEvent.eventName, () => {\n      for (const group of this.#flameChartData.groups) {\n        // We only need to update the color here, because FlameChart will call `scheduleUpdate()` when theme is changed.\n        group.style.color = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n        group.style.backgroundColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-background');\n      }\n    });\n  }\n\n  /**\n   * Given a trace event returns instantiates a legacy SDK.Event. This should\n   * be used for compatibility purposes only.\n   */\n  getLegacyEvent(event: TraceEngine.Types.TraceEvents.TraceEventData): SDK.TracingModel.Event|null {\n    const process = this.#legacyTimelineModel.tracingModel()?.getProcessById(event.pid);\n    const thread = process?.threadById(event.tid);\n    if (!thread) {\n      return null;\n    }\n    return SDK.TracingModel.PayloadEvent.fromPayload(event as unknown as SDK.TracingManager.EventPayload, thread);\n  }\n\n  timingsTrackAppender(): TimingsTrackAppender {\n    return this.#timingsTrackAppender;\n  }\n\n  interactionsTrackAppender(): InteractionsTrackAppender {\n    return this.#interactionsTrackAppender;\n  }\n\n  gpuTrackAppender(): GPUTrackAppender {\n    return this.#gpuTrackAppender;\n  }\n\n  layoutShiftsTrackAppender(): LayoutShiftsTrackAppender {\n    return this.#layoutShiftsTrackAppender;\n  }\n\n  /**\n   * Get the index of the event.\n   * This ${index}-th elements in entryData, flameChartData.entryLevels, flameChartData.entryTotalTimes,\n   * flameChartData.entryStartTimes are all related to this event.\n   */\n  indexForEvent(event: TraceEngine.Types.TraceEvents.TraceEventData): number|undefined {\n    return this.#indexForEvent.get(event);\n  }\n\n  eventsInTrack(trackAppenderName: TrackAppenderName): TraceEngine.Types.TraceEvents.TraceEventData[] {\n    const cachedData = this.#eventsForTrack.get(trackAppenderName);\n    if (cachedData) {\n      return cachedData;\n    }\n\n    // Calculate the levels occupied by a track.\n    let trackStartLevel = null;\n    let trackEndLevel = null;\n    for (const [level, track] of this.#trackForLevel) {\n      if (track.appenderName !== trackAppenderName) {\n        continue;\n      }\n      if (trackStartLevel === null) {\n        trackStartLevel = level;\n      }\n      trackEndLevel = level;\n    }\n\n    if (trackStartLevel === null || trackEndLevel === null) {\n      throw new Error(`Could not find events for track: ${trackAppenderName}`);\n    }\n    const entryLevels = this.#flameChartData.entryLevels;\n    const events = [];\n    for (let i = 0; i < entryLevels.length; i++) {\n      if (trackStartLevel <= entryLevels[i] && entryLevels[i] <= trackEndLevel) {\n        events.push(this.#entryData[i] as TraceEngine.Types.TraceEvents.TraceEventData);\n      }\n    }\n    events.sort((a, b) => a.ts - b.ts);\n    this.#eventsForTrack.set(trackAppenderName, events);\n    return events;\n  }\n\n  /**\n   * Determines if the given events, which are assumed to be ordered can\n   * be organized into tree structures.\n   * This condition is met if there is *not* a pair of async events\n   * e1 and e2 where:\n   *\n   * e1.startTime <= e2.startTime && e1.endTime > e2.startTime && e1.endTime > e2.endTime.\n   * or, graphically:\n   * |------- e1 ------|\n   *   |------- e2 --------|\n   *\n   * Because a parent-child relationship cannot be made from the example\n   * above, a tree cannot be made from the set of events.\n   *\n   * Note that this will also return true if multiple trees can be\n   * built, for example if none of the events overlap with each other.\n   */\n  canBuildTreesFromEvents(events: readonly TraceEngine.Types.TraceEvents.TraceEventData[]): boolean {\n    const stack: TraceEngine.Types.TraceEvents.TraceEventData[] = [];\n    for (const event of events) {\n      const startTime = event.ts;\n      const endTime = event.ts + (event.dur || 0);\n      let parent = stack.at(-1);\n      if (parent === undefined) {\n        stack.push(event);\n        continue;\n      }\n      let parentEndTime = parent.ts + (parent.dur || 0);\n      // Discard events that are not parents for this event. The parent\n      // is one whose end time is after this event start time.\n      while (stack.length && startTime >= parentEndTime) {\n        stack.pop();\n        parent = stack.at(-1);\n\n        if (parent === undefined) {\n          break;\n        }\n        parentEndTime = parent.ts + (parent.dur || 0);\n      }\n      if (stack.length && endTime > parentEndTime) {\n        // If such an event exists but its end time is before this\n        // event's end time, then a tree cannot be made using this\n        // events.\n        return false;\n      }\n      stack.push(event);\n    }\n    return true;\n  }\n\n  /**\n   * Gets the events to be shown in the tree views of the details pane\n   * (Bottom-up, Call tree, etc.). These are the events from the track\n   * that can be arranged in a tree shape.\n   */\n  eventsForTreeView(trackAppenderName: TrackAppenderName): TraceEngine.Types.TraceEvents.TraceEventData[] {\n    const cachedData = this.#trackEventsForTreeview.get(trackAppenderName);\n    if (cachedData) {\n      return cachedData;\n    }\n\n    let trackEvents = this.eventsInTrack(trackAppenderName);\n    if (!this.canBuildTreesFromEvents(trackEvents)) {\n      // Some tracks can include both async and sync events. When this\n      // happens, we use all events for the tree views if a trees can be\n      // built from both sync and async events. If this is not possible,\n      // async events are filtered out and only sync events are used\n      // (it's assumed a tree can always be built using a tracks sync\n      // events).\n      trackEvents = trackEvents.filter(e => !TraceEngine.Types.TraceEvents.isAsyncPhase(e.ph));\n    }\n    this.#trackEventsForTreeview.set(trackAppenderName, trackEvents);\n    return trackEvents;\n  }\n\n  /**\n   * Caches the track appender that owns a flame chart group. FlameChart\n   * groups are created for each track in the timeline. When an user\n   * selects a track in the UI, the track's group is passed to the model\n   * layer to inform about the selection.\n   */\n  registerTrackForGroup(group: PerfUI.FlameChart.Group, appender: TrackAppender): void {\n    this.#flameChartData.groups.push(group);\n    this.#trackForGroup.set(group, appender);\n  }\n\n  /**\n   * Given a FlameChart group, gets the events to be shown in the tree\n   * views if that group was registered by the appender system.\n   */\n  groupEventsForTreeView(group: PerfUI.FlameChart.Group): TraceEngine.Types.TraceEvents.TraceEventData[]|null {\n    const track = this.#trackForGroup.get(group);\n    if (!track) {\n      return null;\n    }\n    return this.eventsForTreeView(track.appenderName);\n  }\n\n  /**\n   * Caches the track appender that owns a level. An appender takes\n   * ownership of a level when it appends data to it.\n   * The cache is useful to determine what appender should handle a\n   * query from the flame chart renderer when an event's feature (like\n   * style, title, etc.) is needed.\n   */\n  registerTrackForLevel(level: number, appender: TrackAppender): void {\n    // TODO(crbug.com/1442454) Figure out how to avoid the circular calls.\n    this.#trackForLevel.set(level, appender);\n  }\n\n  /**\n   * Adds an event to the flame chart data at a defined level.\n   * @param event the event to be appended,\n   * @param level the level to append the event,\n   * @param appender the track which the event belongs to.\n   * @returns the index of the event in all events to be rendered in the flamechart.\n   */\n  appendEventAtLevel(event: TraceEngine.Types.TraceEvents.TraceEventData, level: number, appender: TrackAppender):\n      number {\n    // TODO(crbug.com/1442454) Figure out how to avoid the circular calls.\n    this.#trackForLevel.set(level, appender);\n\n    const index = this.#entryData.length;\n    this.#entryData.push(event);\n    this.#indexForEvent.set(event, index);\n    this.#legacyEntryTypeByLevel[level] = EntryType.TrackAppender;\n    this.#flameChartData.entryLevels[index] = level;\n    this.#flameChartData.entryStartTimes[index] = TraceEngine.Helpers.Timing.microSecondsToMilliseconds(event.ts);\n    const msDuration = event.dur ||\n        TraceEngine.Helpers.Timing.millisecondsToMicroseconds(\n            InstantEventVisibleDurationMs as TraceEngine.Types.Timing.MilliSeconds);\n    this.#flameChartData.entryTotalTimes[index] = TraceEngine.Helpers.Timing.microSecondsToMilliseconds(msDuration);\n    return index;\n  }\n\n  /**\n   * Adds into the flame chart data a list of trace events.\n   * @param events the trace events that will be appended to the flame chart.\n   * The events should be taken straight from the trace handlers. The handlers\n   * should sort the events by start time, and the parent event is before the\n   * child.\n   * @param trackStartLevel the flame chart level from which the events will\n   * be appended.\n   * @param appender the track that the trace events belong to.\n   * @returns the next level after the last occupied by the appended these\n   * trace events (the first available level to append next track).\n   */\n  appendEventsAtLevel(\n      events: readonly TraceEngine.Types.TraceEvents.TraceEventData[], trackStartLevel: number,\n      appender: TrackAppender): number {\n    const lastUsedTimeByLevel: number[] = [];\n    for (let i = 0; i < events.length; ++i) {\n      const event = events[i];\n      const eventAsLegacy = this.getLegacyEvent(event);\n      // Default styles are globally defined for each event name. Some\n      // events are hidden by default.\n      const visibleNames = new Set(TimelineUIUtils.visibleTypes());\n      const eventIsVisible = eventAsLegacy &&\n          visibleNames.has(TimelineModel.TimelineModelFilter.TimelineVisibleEventsFilter.eventType(eventAsLegacy));\n      if (!eventIsVisible) {\n        continue;\n      }\n\n      const level = getEventLevel(event, lastUsedTimeByLevel);\n      this.appendEventAtLevel(event, trackStartLevel + level, appender);\n    }\n\n    this.#legacyEntryTypeByLevel.length = trackStartLevel + lastUsedTimeByLevel.length;\n    this.#legacyEntryTypeByLevel.fill(EntryType.TrackAppender, trackStartLevel);\n\n    return trackStartLevel + lastUsedTimeByLevel.length;\n  }\n\n  /**\n   * Gets the all track appenders that have been set to be visible.\n   */\n  allVisibleTrackAppenders(): TrackAppender[] {\n    return this.#allTrackAppenders.filter(track => this.#visibleTrackNames.has(track.appenderName));\n  }\n\n  /**\n   * Sets the visible tracks internally\n   * @param visibleTracks set with the names of the visible track\n   * appenders. If undefined, all tracks are set to be visible.\n   */\n  setVisibleTracks(visibleTracks?: Set<TrackAppenderName>): void {\n    if (!visibleTracks) {\n      this.#visibleTrackNames = new Set([...TrackNames]);\n      return;\n    }\n    this.#visibleTrackNames = visibleTracks;\n  }\n\n  /**\n   * Returns the color an event is shown with in the timeline.\n   */\n  colorForEvent(event: TraceEngine.Types.TraceEvents.TraceEventData, level: number): string {\n    const track = this.#trackForLevel.get(level);\n    if (!track) {\n      throw new Error('Track not found for level');\n    }\n    return track.colorForEvent(event);\n  }\n  /**\n   * Returns the title an event is shown with in the timeline.\n   */\n  titleForEvent(event: TraceEngine.Types.TraceEvents.TraceEventData, level: number): string {\n    const track = this.#trackForLevel.get(level);\n    if (!track) {\n      throw new Error('Track not found for level');\n    }\n    return track.titleForEvent(event);\n  }\n  /**\n   * Returns the info shown when an event in the timeline is hovered.\n   */\n  highlightedEntryInfo(event: TraceEngine.Types.TraceEvents.TraceEventData, level: number): HighlightedEntryInfo {\n    const track = this.#trackForLevel.get(level);\n    if (!track) {\n      throw new Error('Track not found for level');\n    }\n    return track.highlightedEntryInfo(event);\n  }\n}\n"]}