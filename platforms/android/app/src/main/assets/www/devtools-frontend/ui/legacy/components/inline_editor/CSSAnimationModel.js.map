{"version":3,"file":"CSSAnimationModel.js","sourceRoot":"","sources":["../../../../../../../../front_end/ui/legacy/components/inline_editor/CSSAnimationModel.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../../../core/sdk/sdk.js';\nimport * as CodeMirror from '../../../../third_party/codemirror.next/codemirror.next.js';\nimport * as UI from '../../../../ui/legacy/legacy.js';\n\nconst cssParser = CodeMirror.css.cssLanguage.parser;\n\nconst enum LonghandPart {\n  Direction = 'D',\n  FillMode = 'F',\n  PlayState = 'P',\n  IterationCount = 'I',\n  EasingFunction = 'E',\n}\n\nconst identifierLonghandMap: Map<string, LonghandPart> = new Map(\n    Object.entries({\n      'normal': LonghandPart.Direction,\n      'alternate': LonghandPart.Direction,\n      'reverse': LonghandPart.Direction,\n      'alternate-reverse': LonghandPart.Direction,\n      'none': LonghandPart.FillMode,\n      'forwards': LonghandPart.FillMode,\n      'backwards': LonghandPart.FillMode,\n      'both': LonghandPart.FillMode,\n      'running': LonghandPart.PlayState,\n      'paused': LonghandPart.PlayState,\n      'infinite': LonghandPart.IterationCount,\n      'linear': LonghandPart.EasingFunction,\n      'ease': LonghandPart.EasingFunction,\n      'ease-in': LonghandPart.EasingFunction,\n      'ease-out': LonghandPart.EasingFunction,\n      'ease-in-out': LonghandPart.EasingFunction,\n    }),\n);\n\nfunction tokenize(text: string): string[] {\n  const textToParse = `*{animation:${text};}`;\n  const parsed = cssParser.parse(textToParse);\n  // Take the cursor from declaration\n  const cursor = parsed.cursorAt(textToParse.indexOf(':') + 1);\n  cursor.firstChild();\n  cursor.nextSibling();\n\n  const tokens: string[] = [];\n  while (cursor.nextSibling()) {\n    tokens.push(textToParse.substring(cursor.from, cursor.to));\n  }\n  return tokens;\n}\n\n/**\n * For animation shorthand, we can show two swatches:\n * - Easing function swatch (or also called bezier swatch)\n * - Animation name swatch\n * - Variable swatch\n * all the other tokens in the shorthands are rendered as text.\n *\n * This helper model takes an animation shorthand value (`1s linear slide-in`)\n * and finds out which parts to render as \"what\" by taking its syntax and parsing logic\n * into consideration. Details can be found here: https://w3c.github.io/csswg-drafts/css-animations/#animation.\n *\n * The rule says that whenever there is a keyword that is valid for a property other than\n * `animation-name` whose values are not found earlier in the shorthand must be accepted\n * for those properties rather than for `animation-name`.\n *\n * Beware that, an animation shorthand can contain multiple animation definitions that are\n * separated by a comma (The syntax is animation = <single-animation>#). The above rule only\n * applies to parsing of <single-animation>.\n */\nexport class CSSAnimationModel {\n  parts: Part[];\n  private constructor(parts: Part[]) {\n    this.parts = parts;\n  }\n\n  static parse(text: string, animationNames: string[]): CSSAnimationModel {\n    const tokens = tokenize(text);\n    // `animationNames` can be an array that map to the animation names of\n    // different single animations in the order of presence.\n    let searchedAnimationNameIndex = 0;\n    const parts: Part[] = [];\n    const foundLonghands = {\n      [LonghandPart.EasingFunction]: false,\n      [LonghandPart.IterationCount]: false,\n      [LonghandPart.Direction]: false,\n      [LonghandPart.FillMode]: false,\n      [LonghandPart.PlayState]: false,\n    };\n\n    for (const token of tokens) {\n      const matchedLonghandPart = identifierLonghandMap.get(token);\n      const matchesToLonghand = matchedLonghandPart && !foundLonghands[matchedLonghandPart];\n\n      let type: PartType = PartType.Text;\n      if (token.match(UI.Geometry.CubicBezier.Regex) && !foundLonghands[LonghandPart.EasingFunction]) {\n        type = PartType.EasingFunction;\n      } else if (token.match(SDK.CSSMetadata.VariableRegex)) {\n        // Note: currently we don't handle resolving variables\n        // and putting them in their respective longhand parts.\n        // So, having a variable might break the logic for deciding on the\n        // `animation-name` if the variable matches to a longhand\n        // keyword and the `animation-name` is also the same keyword.\n        // This case is very unlikely so we don't handle it for the\n        // sake of keeping the implementation clearer.\n        type = PartType.Variable;\n      } else if (token === animationNames[searchedAnimationNameIndex] && !matchesToLonghand) {\n        type = PartType.AnimationName;\n      }\n\n      parts.push({\n        type,\n        value: token,\n      });\n\n      // Mark the longhand part as found so that\n      // the next identifier that might match to\n      // this longhand part shouldn't match.\n      if (matchedLonghandPart) {\n        foundLonghands[matchedLonghandPart] = true;\n      }\n\n      if (token === ',') {\n        // `token` being equal to `,` means that parsing of a `<single-animation>`\n        // is complete and we start parsing of the next `<single-animation>`.\n        // Because of that, we're resetting `foundLonghands` and moving the\n        // animation name to match.\n        for (const longhandPart of Object.keys(foundLonghands)) {\n          foundLonghands[longhandPart as LonghandPart] = false;\n        }\n        searchedAnimationNameIndex++;\n      }\n    }\n\n    return new CSSAnimationModel(parts);\n  }\n}\n\nexport const enum PartType {\n  // Things that should be rendered as text\n  Text = 'T',\n  // Things that should be rendered with bezier swatch\n  EasingFunction = 'EF',\n  // Things that should be rendered with animation name swatch\n  AnimationName = 'AN',\n  // Things that should be rendered with variable swatch\n  Variable = 'V',\n}\n\ntype Part = {\n  type: PartType,\n  value: string,\n};\n"]}