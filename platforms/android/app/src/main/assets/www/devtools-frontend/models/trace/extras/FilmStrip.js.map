{"version":3,"file":"FilmStrip.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/extras/FilmStrip.ts"],"names":[],"mappings":"AAMA,OAAO,KAAK,QAAQ,MAAM,oCAAoC,CAAC;AAY/D,8BAA8B;AAC9B,kCAAkC;AAClC,qBAAqB;AACrB,MAAM,cAAc,GAAG,IAAI,GAAG,EAAsF,CAAC;AAErH,MAAM,UAAU,wBAAwB,CACpC,SAA8C,EAAE,cAA0C;IAC5F,MAAM,MAAM,GAAqB,EAAE,CAAC;IAEpC,MAAM,QAAQ,GAAG,OAAO,cAAc,KAAK,WAAW,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;IACzG,MAAM,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;IAC/D,IAAI,SAAS,EAAE;QACb,OAAO,SAAS,CAAC;KAClB;IAED,KAAK,MAAM,UAAU,IAAI,SAAS,CAAC,WAAW,EAAE;QAC9C,IAAI,UAAU,CAAC,EAAE,GAAG,QAAQ,EAAE;YAC5B,SAAS;SACV;QACD,MAAM,KAAK,GAAmB;YAC5B,KAAK,EAAE,MAAM,CAAC,MAAM;YACpB,eAAe,EAAE,UAAU;YAC3B,kBAAkB,EAAE,UAAU,CAAC,IAAI,CAAC,QAAQ;SAC7C,CAAC;QACF,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KACpB;IAED,MAAM,MAAM,GAAG;QACb,MAAM,EAAE,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC;KAC3B,CAAC;IAEF,MAAM,aAAa,GAAG,QAAQ,CAAC,YAAY,CAAC,cAAc,CACtD,cAAc,EAAE,SAAS,EAAE,GAAG,EAAE,CAAC,IAAI,GAAG,EAA4C,CAAC,CAAC;IAC1F,aAAa,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IAEpC,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,UAAU,uBAAuB,CACnC,SAAwB,EAAE,eAA0C;IACtE,MAAM,gCAAgC,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAChF,SAAS,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,eAAe,CAAC,EAAE,GAAG,eAAe,CAAC,CAAC;IAC3E,IAAI,gCAAgC,KAAK,IAAI,EAAE;QAC7C,OAAO,IAAI,CAAC;KACb;IACD,OAAO,SAAS,CAAC,MAAM,CAAC,gCAAgC,CAAC,CAAC;AAC5D,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n//\nimport type * as Types from '../types/types.js';\nimport type * as Handlers from '../handlers/handlers.js';\nimport * as Platform from '../../../core/platform/platform.js';\n\nexport interface FilmStripData {\n  frames: readonly FilmStripFrame[];\n}\n\nexport interface FilmStripFrame {\n  screenshotEvent: Types.TraceEvents.TraceEventSnapshot;\n  screenshotAsString: string;\n  index: number;\n}\n\n// Cache film strips based on:\n// 1. The trace parsed data object\n// 2. The start time.\nconst filmStripCache = new Map<Handlers.Migration.PartialTraceData, Map<Types.Timing.MicroSeconds, FilmStripData>>();\n\nexport function filmStripFromTraceEngine(\n    traceData: Handlers.Migration.PartialTraceData, customZeroTime?: Types.Timing.MicroSeconds): FilmStripData {\n  const frames: FilmStripFrame[] = [];\n\n  const zeroTime = typeof customZeroTime !== 'undefined' ? customZeroTime : traceData.Meta.traceBounds.min;\n  const fromCache = filmStripCache.get(traceData)?.get(zeroTime);\n  if (fromCache) {\n    return fromCache;\n  }\n\n  for (const screenshot of traceData.Screenshots) {\n    if (screenshot.ts < zeroTime) {\n      continue;\n    }\n    const frame: FilmStripFrame = {\n      index: frames.length,\n      screenshotEvent: screenshot,\n      screenshotAsString: screenshot.args.snapshot,\n    };\n    frames.push(frame);\n  }\n\n  const result = {\n    frames: Array.from(frames),\n  };\n\n  const cachedForData = Platform.MapUtilities.getWithDefault(\n      filmStripCache, traceData, () => new Map<Types.Timing.MicroSeconds, FilmStripData>());\n  cachedForData.set(zeroTime, result);\n\n  return result;\n}\n\nexport function frameClosestToTimestamp(\n    filmStrip: FilmStripData, searchTimestamp: Types.Timing.MicroSeconds): FilmStripFrame|null {\n  const closestFrameIndexBeforeTimestamp = Platform.ArrayUtilities.nearestIndexFromEnd(\n      filmStrip.frames, frame => frame.screenshotEvent.ts < searchTimestamp);\n  if (closestFrameIndexBeforeTimestamp === null) {\n    return null;\n  }\n  return filmStrip.frames[closestFrameIndexBeforeTimestamp];\n}\n"]}