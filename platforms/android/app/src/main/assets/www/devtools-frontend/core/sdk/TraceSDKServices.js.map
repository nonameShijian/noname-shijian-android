{"version":3,"file":"TraceSDKServices.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/TraceSDKServices.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as TraceEngine from '../../models/trace/trace.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport {DOMModel, type DOMNode} from './DOMModel.js';\nimport {TargetManager} from './TargetManager.js';\nimport {CPUThrottlingManager} from './CPUThrottlingManager.js';\nimport {MultitargetNetworkManager} from './NetworkManager.js';\n\nconst domLookUpSingleNodeCache =\n    new Map<TraceEngine.Handlers.Types.TraceParseData, Map<Protocol.DOM.BackendNodeId, DOMNode|null>>();\nconst domLookUpBatchNodesCache = new Map<\n    TraceEngine.Handlers.Types.TraceParseData,\n    Map<Set<Protocol.DOM.BackendNodeId>, Map<Protocol.DOM.BackendNodeId, DOMNode|null>>>();\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function _TEST_clearCache(): void {\n  domLookUpSingleNodeCache.clear();\n  domLookUpBatchNodesCache.clear();\n  layoutShiftSourcesCache.clear();\n  normalizedLayoutShiftNodesCache.clear();\n}\n\n/**\n * Looks up the DOM Node on the page for the given BackendNodeId. Uses the\n * provided TraceParseData as the cache and will cache the result after the\n * first lookup.\n */\nexport async function domNodeForBackendNodeID(\n    modelData: TraceEngine.Handlers.Types.TraceParseData, nodeId: Protocol.DOM.BackendNodeId): Promise<DOMNode|null> {\n  const fromCache = domLookUpSingleNodeCache.get(modelData)?.get(nodeId);\n  if (fromCache !== undefined) {\n    return fromCache;\n  }\n\n  const target = TargetManager.instance().primaryPageTarget();\n  const domModel = target?.model(DOMModel);\n  if (!domModel) {\n    return null;\n  }\n\n  const domNodesMap = await domModel.pushNodesByBackendIdsToFrontend(new Set([nodeId]));\n  const result = domNodesMap?.get(nodeId) || null;\n\n  const cacheForModel = domLookUpSingleNodeCache.get(modelData) || new Map<Protocol.DOM.BackendNodeId, DOMNode|null>();\n  cacheForModel.set(nodeId, result);\n  domLookUpSingleNodeCache.set(modelData, cacheForModel);\n\n  return result;\n}\n\n/**\n * Takes a set of Protocol.DOM.BackendNodeId ids and will return a map of NodeId=>DOMNode.\n * Results are cached based on 1) the provided TraceParseData and 2) the provided set of IDs.\n */\nexport async function domNodesForMultipleBackendNodeIds(\n    modelData: TraceEngine.Handlers.Types.TraceParseData,\n    nodeIds: Set<Protocol.DOM.BackendNodeId>): Promise<Map<Protocol.DOM.BackendNodeId, DOMNode|null>> {\n  const fromCache = domLookUpBatchNodesCache.get(modelData)?.get(nodeIds);\n  if (fromCache) {\n    return fromCache;\n  }\n  const target = TargetManager.instance().primaryPageTarget();\n  const domModel = target?.model(DOMModel);\n  if (!domModel) {\n    return new Map();\n  }\n\n  const domNodesMap = await domModel.pushNodesByBackendIdsToFrontend(nodeIds) || new Map();\n\n  const cacheForModel = domLookUpBatchNodesCache.get(modelData) ||\n      new Map<Set<Protocol.DOM.BackendNodeId>, Map<Protocol.DOM.BackendNodeId, DOMNode|null>>();\n  cacheForModel.set(nodeIds, domNodesMap);\n  domLookUpBatchNodesCache.set(modelData, cacheForModel);\n\n  return domNodesMap;\n}\n\nconst layoutShiftSourcesCache = new Map<\n    TraceEngine.Handlers.Types.TraceParseData,\n    Map<TraceEngine.Types.TraceEvents.TraceEventLayoutShift, readonly LayoutShiftSource[]>>();\n\nconst normalizedLayoutShiftNodesCache = new Map<\n    TraceEngine.Handlers.Types.TraceParseData,\n    Map<TraceEngine.Types.TraceEvents.TraceEventLayoutShift,\n        readonly TraceEngine.Types.TraceEvents.TraceImpactedNode[]>>();\n\nexport interface LayoutShiftSource {\n  previousRect: DOMRect;\n  currentRect: DOMRect;\n  node: DOMNode;\n}\n\n/**\n * Calculates and returns a list of sources for a LayoutShift.\n * Here, a source is considered as a node that moved and contributed to the\n * given LayoutShift existing and the score it was given. Each source returned\n * contains a reference to the DOM Node, and its dimensions (as a DOMRect), both\n * before and now, so we can see how this node changed and how that impacted the\n * layout shift.\n *\n * This data is cached based on the provided model data and the given layout\n * shift, so it is is safe to call multiple times with the same input.\n */\nexport async function sourcesForLayoutShift(\n    modelData: TraceEngine.Handlers.Types.TraceParseData,\n    event: TraceEngine.Types.TraceEvents.TraceEventLayoutShift): Promise<readonly LayoutShiftSource[]> {\n  const fromCache = layoutShiftSourcesCache.get(modelData)?.get(event);\n  if (fromCache) {\n    return fromCache;\n  }\n  const impactedNodes = event.args.data?.impacted_nodes;\n  if (!impactedNodes) {\n    return [];\n  }\n  const sources: LayoutShiftSource[] = [];\n  await Promise.all(impactedNodes.map(async node => {\n    const domNode = await domNodeForBackendNodeID(modelData, node.node_id);\n    if (domNode) {\n      sources.push({\n        previousRect: new DOMRect(node.old_rect[0], node.old_rect[1], node.old_rect[2], node.old_rect[3]),\n        currentRect: new DOMRect(node.new_rect[0], node.new_rect[1], node.new_rect[2], node.new_rect[3]),\n        node: domNode,\n      });\n    }\n  }));\n  const cacheForModel = layoutShiftSourcesCache.get(modelData) ||\n      new Map<TraceEngine.Types.TraceEvents.TraceEventLayoutShift, LayoutShiftSource[]>();\n  cacheForModel.set(event, sources);\n  layoutShiftSourcesCache.set(modelData, cacheForModel);\n  return sources;\n}\n\n/**\n * Takes a LayoutShift and normalizes its node dimensions based on the device\n * pixel ratio (DPR) of the user's display.\n * This is required because the Layout Instability API is not based on CSS\n * pixels, but physical pixels. Therefore we need to map these to normalized CSS\n * pixels if we can. For example, if the user is on a device with a DPR of 2,\n * the values of the node dimensions reported by the Instability API need to be\n * divided by 2 to be accurate.\n * This function is safe to call multiple times as results are cached based on\n * the provided model data.\n * See https://crbug.com/1300309 for details.\n */\nexport async function normalizedImpactedNodesForLayoutShift(\n    modelData: TraceEngine.Handlers.Types.TraceParseData, event: TraceEngine.Types.TraceEvents.TraceEventLayoutShift):\n    Promise<readonly TraceEngine.Types.TraceEvents.TraceImpactedNode[]> {\n  const fromCache = normalizedLayoutShiftNodesCache.get(modelData)?.get(event);\n  if (fromCache) {\n    return fromCache;\n  }\n  const impactedNodes = event.args?.data?.impacted_nodes;\n  if (!impactedNodes) {\n    return [];\n  }\n\n  let viewportScale: number|null = null;\n  const target = TargetManager.instance().primaryPageTarget();\n  // Get the CSS-to-physical pixel ratio of the device the inspected\n  // target is running at.\n  const evaluateResult = await target?.runtimeAgent().invoke_evaluate({expression: 'window.devicePixelRatio'});\n  if (evaluateResult?.result.type === 'number') {\n    viewportScale = evaluateResult?.result.value as number ?? null;\n  }\n\n  if (!viewportScale) {\n    // Bail and return the nodes as is.\n    return impactedNodes;\n  }\n\n  const normalizedNodes: TraceEngine.Types.TraceEvents.TraceImpactedNode[] = [];\n  for (const impactedNode of impactedNodes) {\n    const newNode = {...impactedNode};\n    for (let i = 0; i < impactedNode.old_rect.length; i++) {\n      newNode.old_rect[i] /= viewportScale;\n    }\n    for (let i = 0; i < impactedNode.new_rect.length; i++) {\n      newNode.new_rect[i] /= viewportScale;\n    }\n    normalizedNodes.push(newNode);\n  }\n\n  const cacheForModel = normalizedLayoutShiftNodesCache.get(modelData) ||\n      new Map<TraceEngine.Types.TraceEvents.TraceEventLayoutShift,\n              readonly TraceEngine.Types.TraceEvents.TraceImpactedNode[]>();\n  cacheForModel.set(event, normalizedNodes);\n  normalizedLayoutShiftNodesCache.set(modelData, cacheForModel);\n\n  return normalizedNodes;\n}\n\nexport async function getMetadataForFreshRecording(recordStartTime?: number):\n    Promise<TraceEngine.TraceModel.TraceFileMetaData|undefined> {\n  try {\n    const cpuThrottlingManager = CPUThrottlingManager.instance();\n\n    // If the CPU Throttling manager has yet to have its primary page target\n    // set, it will block on the call to get the current hardware concurrency\n    // until it does. At this point where the user has recorded a trace, that\n    // target should have been set. So if it doesn't have it set, we instead\n    // just bail and don't store the hardware concurrency (this is only\n    // metadata, not mission critical information).\n    // We also race this call against a 1s timeout, because sometimes this call\n    // can hang (unsure exactly why) and we do not want to block parsing for\n    // too long as a result.\n    function getConcurrencyOrTimeout(): Promise<number|undefined> {\n      return Promise.race([\n        CPUThrottlingManager.instance().getHardwareConcurrency(),\n        new Promise<undefined>(resolve => {\n          setTimeout(() => resolve(undefined), 1_000);\n        }),\n      ]);\n    }\n\n    const hardwareConcurrency =\n        cpuThrottlingManager.hasPrimaryPageTargetSet() ? await getConcurrencyOrTimeout() : undefined;\n    const cpuThrottling = CPUThrottlingManager.instance().cpuThrottlingRate();\n    const networkConditions = MultitargetNetworkManager.instance().networkConditions();\n    const networkTitle =\n        typeof networkConditions.title === 'function' ? networkConditions.title() : networkConditions.title;\n\n    return {\n      source: 'DevTools',\n      startTime: recordStartTime ? new Date(recordStartTime).toJSON() : undefined,  // ISO-8601 timestamp\n      cpuThrottling,\n      networkThrottling: networkTitle,\n      hardwareConcurrency,\n    };\n  } catch {\n    // If anything went wrong, it does not really matter. The impact is that we\n    // will not save the metadata when we save the trace to disk, but that is\n    // not really important, so just return undefined and move on\n    return undefined;\n  }\n}\n"]}