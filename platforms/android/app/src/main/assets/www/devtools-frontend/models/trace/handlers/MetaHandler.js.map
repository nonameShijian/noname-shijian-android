{"version":3,"file":"MetaHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/MetaHandler.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,QAAQ,MAAM,oCAAoC,CAAC;AAC/D,OAAO,KAAK,KAAK,MAAM,mBAAmB,CAAC;AAI3C,qFAAqF;AACrF,MAAM,0BAA0B,GAAG,IAAI,GAAG,EAEsE,CAAC;AAEjH,4EAA4E;AAC5E,0DAA0D;AAC1D,IAAI,WAAW,GAAW,EAAE,CAAC;AAC7B,IAAI,YAAY,GAAW,EAAE,CAAC;AAE9B,6EAA6E;AAC7E,gDAAgD;AAChD,IAAI,gBAAgB,GAAgC,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AACpF,IAAI,eAAe,GAA+B,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;AACjF,IAAI,YAAY,GAAgC,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AAChF,IAAI,WAAW,GAA+B,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7E,IAAI,YAAY,GAAiB,IAAI,CAAC;AAEtC,MAAM,mBAAmB,GAAG,IAAI,GAAG,EAA+B,CAAC;AACnE,MAAM,WAAW,GAA6B;IAC5C,GAAG,EAAE,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,iBAAiB,CAAC;IACxD,GAAG,EAAE,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,iBAAiB,CAAC;IACxD,KAAK,EAAE,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,iBAAiB,CAAC;CAC3D,CAAC;AAEF;;;;;;;;;GASG;AACH,MAAM,oBAAoB,GAAG,IAAI,GAAG,EAAyD,CAAC;AAC9F,MAAM,yBAAyB,GAAG,IAAI,GAAG,EAAuD,CAAC;AAEjG,6FAA6F;AAC7F,8FAA8F;AAC9F,MAAM,gBAAgB,GAClB,IAAI,GAAG,EAAwG,CAAC;AAEpH,IAAI,gBAAgB,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;AACrD,MAAM,mCAAmC,GAAG,IAAI,GAAG,CAAC;;;;;CAKnD,CAAC,CAAC;AAEH,IAAI,YAAY,qCAA6B,CAAC;AAC9C,MAAM,UAAU,KAAK;IACnB,oBAAoB,CAAC,KAAK,EAAE,CAAC;IAC7B,yBAAyB,CAAC,KAAK,EAAE,CAAC;IAElC,gBAAgB,GAAG,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IACnD,eAAe,GAAG,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IACjD,YAAY,GAAG,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/C,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7C,YAAY,GAAG,IAAI,CAAC;IACpB,mBAAmB,CAAC,KAAK,EAAE,CAAC;IAC5B,gBAAgB,CAAC,KAAK,EAAE,CAAC;IACzB,0BAA0B,CAAC,KAAK,EAAE,CAAC;IAEnC,WAAW,CAAC,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;IACtE,WAAW,CAAC,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;IACtE,WAAW,CAAC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;IACxE,gBAAgB,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;IAEjD,YAAY,qCAA6B,CAAC;AAC5C,CAAC;AAED,MAAM,UAAU,UAAU;IACxB,IAAI,YAAY,uCAA+B,EAAE;QAC/C,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;KAC/C;IAED,YAAY,mCAA2B,CAAC;AAC1C,CAAC;AAED,SAAS,4BAA4B,CACjC,KAAuC,EAAE,KAAmC;IAC9E,MAAM,sBAAsB,GAAG,QAAQ,CAAC,YAAY,CAAC,cAAc,CAC/D,0BAA0B,EAAE,KAAK,CAAC,KAAK,EACvC,GAAG,EAAE,CAAC,IAAI,GAAG,EAC8F,CAAC,CAAC;IACjH,MAAM,mBAAmB,GAAG,QAAQ,CAAC,YAAY,CAAC,cAAc,CAAC,sBAAsB,EAAE,KAAK,CAAC,SAAS,EAAE,GAAG,EAAE;QAC7G,OAAO;YACL,KAAK;YACL,MAAM,EAAE;gBACN,GAAG,EAAE,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;gBACjC,GAAG,EAAE,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;gBACjC,KAAK,EAAE,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;aACpC;SACF,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,kDAAkD;IAClD,IAAI,mBAAmB,CAAC,MAAM,CAAC,GAAG,KAAK,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE;QACnE,OAAO;KACR;IAED,6EAA6E;IAC7E,uEAAuE;IACvE,mBAAmB,CAAC,MAAM,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE,CAAC;AAC5C,CAAC;AAED,MAAM,UAAU,WAAW,CAAC,KAAuC;IACjE,IAAI,YAAY,qCAA6B,EAAE;QAC7C,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;KACpD;IAED,8EAA8E;IAC9E,2EAA2E;IAC3E,+EAA+E;IAC/E,4EAA4E;IAC5E,qDAAqD;IACrD,IAAI,KAAK,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,mCAAmC,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;QACxG,WAAW,CAAC,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;QACjF,MAAM,aAAa,GAAG,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;QAChE,WAAW,CAAC,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG,aAAa,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;KAClG;IAED,IAAI,KAAK,CAAC,WAAW,CAAC,aAAa,CAAC,KAAK,CAAC;QACtC,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,iBAAiB,CAAC,EAAE;QAC5E,gBAAgB,GAAG,KAAK,CAAC,GAAG,CAAC;QAC7B,OAAO;KACR;IAED,IAAI,KAAK,CAAC,WAAW,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,KAAK,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,aAAa,CAAC,EAAE;QAC9G,YAAY,GAAG,KAAK,CAAC,GAAG,CAAC;QACzB,OAAO;KACR;IAED,IAAI,KAAK,CAAC,WAAW,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,WAAW,EAAE;QAC5E,WAAW,GAAG,KAAK,CAAC,GAAG,CAAC;QACxB,OAAO;KACR;IAED,IAAI,KAAK,CAAC,WAAW,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,eAAe,EAAE;QAChF,eAAe,GAAG,KAAK,CAAC,GAAG,CAAC;KAC7B;IAED,IAAI,KAAK,CAAC,WAAW,CAAC,6BAA6B,CAAC,KAAK,CAAC,IAAI,YAAY,KAAK,IAAI,EAAE;QACnF,MAAM,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC;QAClD,MAAM,SAAS,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QACjC,MAAM,SAAS,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QACjC,MAAM,aAAa,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QACrC,MAAM,cAAc,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QACtC,YAAY,GAAG,IAAI,OAAO,CAAC,SAAS,EAAE,SAAS,EAAE,aAAa,EAAE,cAAc,CAAC,CAAC;KACjF;IAED,0EAA0E;IAC1E,6EAA6E;IAC7E,uCAAuC;IACvC,IAAI,KAAK,CAAC,WAAW,CAAC,mCAAmC,CAAC,KAAK,CAAC,EAAE;QAChE,gBAAgB,GAAG,KAAK,CAAC,EAAE,CAAC;QAE5B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;YACpB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;SAClD;QAED,KAAK,MAAM,KAAK,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,EAAE,CAAC,EAAE;YAClD,4BAA4B,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YAE3C,IAAI,KAAK,CAAC,MAAM,EAAE;gBAChB,SAAS;aACV;YAED,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC;YAC1B,YAAY,GAAG,KAAK,CAAC,GAAG,CAAC;YACzB,mBAAmB,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;SAC1C;QACD,OAAO;KACR;IAED,sEAAsE;IACtE,wEAAwE;IACxE,wEAAwE;IACxE,oEAAoE;IACpE,IAAI,KAAK,CAAC,WAAW,CAAC,mCAAmC,CAAC,KAAK,CAAC,EAAE;QAChE,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;QAC9B,IAAI,CAAC,KAAK,EAAE;YACV,OAAO;SACR;QAED,4BAA4B,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAE3C,IAAI,KAAK,CAAC,MAAM,EAAE;YAChB,OAAO;SACR;QAED,mBAAmB,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACzC,OAAO;KACR;IAED,IAAI,KAAK,CAAC,WAAW,CAAC,sBAAsB,CAAC,KAAK,CAAC,EAAE;QACnD,MAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;QAClC,IAAI,CAAC,SAAS,EAAE;YACd,OAAO;SACR;QAED,MAAM,EAAC,KAAK,EAAE,IAAI,EAAE,GAAG,EAAC,GAAG,SAAS,CAAC;QACrC,4BAA4B,CAAC,KAAK,EAAE,EAAC,SAAS,EAAE,KAAK,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,EAAC,CAAC,CAAC;QAC9E,OAAO;KACR;IAED,uDAAuD;IACvD,IAAI,KAAK,CAAC,WAAW,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE;QACzC,MAAM,OAAO,GAAG,QAAQ,CAAC,YAAY,CAAC,cAAc,CAAC,gBAAgB,EAAE,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC;QACnG,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QAC9B,OAAO;KACR;IAED,8EAA8E;IAC9E,6EAA6E;IAC7E,gEAAgE;IAChE,IAAI,KAAK,CAAC,WAAW,CAAC,kCAAkC,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;QAClF,MAAM,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC;QAClD,IAAI,yBAAyB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;YAC/C,MAAM,IAAI,KAAK,CAAC,qEAAqE,CAAC,CAAC;SACxF;QACD,yBAAyB,CAAC,GAAG,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;QAEnD,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;QACjC,MAAM,wBAAwB,GAAG,oBAAoB,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;QACzE,wBAAwB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrC,oBAAoB,CAAC,GAAG,CAAC,OAAO,EAAE,wBAAwB,CAAC,CAAC;QAC5D,OAAO;KACR;AACH,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,QAAQ;IAC5B,IAAI,YAAY,qCAA6B,EAAE;QAC7C,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;KAC/C;IAED,WAAW,CAAC,GAAG,GAAG,gBAAgB,CAAC;IACnC,WAAW,CAAC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;IAEjF,uEAAuE;IACvE,yEAAyE;IACzE,6EAA6E;IAC7E,yEAAyE;IACzE,uEAAuE;IACvE,WAAW;IACX,KAAK,MAAM,CAAC,EAAE,cAAc,CAAC,IAAI,0BAA0B,EAAE;QAC3D,MAAM,mBAAmB,GAAG,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC;QACzD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnD,MAAM,aAAa,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC;YAC7C,MAAM,UAAU,GAAG,mBAAmB,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAE9C,8DAA8D;YAC9D,wFAAwF;YACxF,IAAI,CAAC,UAAU,EAAE;gBACf,aAAa,CAAC,MAAM,CAAC,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;gBACtE,aAAa,CAAC,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,GAAG,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;aACpG;iBAAM;gBACL,aAAa,CAAC,MAAM,CAAC,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;gBAChF,aAAa,CAAC,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,aAAa,CAAC,MAAM,CAAC,GAAG,GAAG,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;aAC7G;SACF;KACF;IAED,iFAAiF;IACjF,0FAA0F;IAC1F,iDAAiD;IACjD,KAAK,MAAM,CAAC,OAAO,EAAE,WAAW,CAAC,IAAI,oBAAoB,EAAE;QACzD,sEAAsE;QACtE,wFAAwF;QACxF,+DAA+D;QAC/D,IAAI,0BAA0B,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;YAC3C,SAAS;SACV;QACD,oBAAoB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACrC,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YACpC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE;gBACzB,SAAS;aACV;YACD,yBAAyB,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;SACrE;KACF;IAED,YAAY,iCAAyB,CAAC;AACxC,CAAC;AAuBD,MAAM,UAAU,IAAI;IAClB,IAAI,YAAY,mCAA2B,EAAE;QAC3C,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;KAClD;IAED,OAAO;QACL,WAAW,EAAE,EAAC,GAAG,WAAW,EAAC;QAC7B,gBAAgB;QAChB,eAAe;QACf,YAAY;QACZ,WAAW,EAAE,WAAW,KAAK,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,WAAW;QACrF,YAAY,EAAE,YAAY,IAAI,SAAS;QACvC,WAAW;QACX,YAAY;QACZ,oBAAoB,EAAE,IAAI,GAAG,CAAC,oBAAoB,CAAC;QACnD,yBAAyB,EAAE,IAAI,GAAG,CAAC,yBAAyB,CAAC;QAC7D,gBAAgB,EAAE,IAAI,GAAG,CAAC,gBAAgB,CAAC;QAC3C,wBAAwB,EAAE,IAAI,GAAG,CAAC,0BAA0B,CAAC;QAC7D,mBAAmB,EAAE,IAAI,GAAG,CAAC,mBAAmB,CAAC;KAClD,CAAC;AACJ,CAAC","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nimport {HandlerState} from './types.js';\n\n// We track the renderer processes we see in each frame on the way through the trace.\nconst rendererProcessesByFrameId = new Map<\n    string,\n    Map<Types.TraceEvents.ProcessID, {window: Types.Timing.TraceWindow, frame: Types.TraceEvents.TraceFrame}>>();\n\n// We will often want to key data by Frame IDs, and commonly we'll care most\n// about the main frame's ID, so we store and expose that.\nlet mainFrameId: string = '';\nlet mainFrameURL: string = '';\n\n// We will often want to key data by the browser process, GPU process and top\n// level renderer IDs, so keep a track on those.\nlet browserProcessId: Types.TraceEvents.ProcessID = Types.TraceEvents.ProcessID(-1);\nlet browserThreadId: Types.TraceEvents.ThreadID = Types.TraceEvents.ThreadID(-1);\nlet gpuProcessId: Types.TraceEvents.ProcessID = Types.TraceEvents.ProcessID(-1);\nlet gpuThreadId: Types.TraceEvents.ThreadID = Types.TraceEvents.ThreadID(-1);\nlet viewportRect: DOMRect|null = null;\n\nconst topLevelRendererIds = new Set<Types.TraceEvents.ProcessID>();\nconst traceBounds: Types.Timing.TraceWindow = {\n  min: Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY),\n  max: Types.Timing.MicroSeconds(Number.NEGATIVE_INFINITY),\n  range: Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY),\n};\n\n/**\n * These represent the user navigating. Values such as First Contentful Paint,\n * etc, are relative to the navigation.\n *\n *  We store navigation events both by the frame and navigation ID. This means\n * when we need to look them up, we can use whichever ID we have.\n *\n * Note that these Maps will have the same values in them; these are just keyed\n * differently to make look-ups easier.\n */\nconst navigationsByFrameId = new Map<string, Types.TraceEvents.TraceEventNavigationStart[]>();\nconst navigationsByNavigationId = new Map<string, Types.TraceEvents.TraceEventNavigationStart>();\n\n// Represents all the threads in the trace, organized by process. This is mostly for internal\n// bookkeeping so that during the finalize pass we can obtain the main and browser thread IDs.\nconst threadsInProcess =\n    new Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>();\n\nlet traceStartedTime = Types.Timing.MicroSeconds(-1);\nconst eventPhasesOfInterestForTraceBounds = new Set([\n  Types.TraceEvents.Phase.BEGIN,\n  Types.TraceEvents.Phase.END,\n  Types.TraceEvents.Phase.COMPLETE,\n  Types.TraceEvents.Phase.INSTANT,\n]);\n\nlet handlerState = HandlerState.UNINITIALIZED;\nexport function reset(): void {\n  navigationsByFrameId.clear();\n  navigationsByNavigationId.clear();\n\n  browserProcessId = Types.TraceEvents.ProcessID(-1);\n  browserThreadId = Types.TraceEvents.ThreadID(-1);\n  gpuProcessId = Types.TraceEvents.ProcessID(-1);\n  gpuThreadId = Types.TraceEvents.ThreadID(-1);\n  viewportRect = null;\n  topLevelRendererIds.clear();\n  threadsInProcess.clear();\n  rendererProcessesByFrameId.clear();\n\n  traceBounds.min = Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY);\n  traceBounds.max = Types.Timing.MicroSeconds(Number.NEGATIVE_INFINITY);\n  traceBounds.range = Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY);\n  traceStartedTime = Types.Timing.MicroSeconds(-1);\n\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('Meta Handler was not reset');\n  }\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nfunction updateRendererProcessByFrame(\n    event: Types.TraceEvents.TraceEventData, frame: Types.TraceEvents.TraceFrame): void {\n  const rendererProcessInFrame = Platform.MapUtilities.getWithDefault(\n      rendererProcessesByFrameId, frame.frame,\n      () => new Map<\n          Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame, window: Types.Timing.TraceWindow}>());\n  const rendererProcessInfo = Platform.MapUtilities.getWithDefault(rendererProcessInFrame, frame.processId, () => {\n    return {\n      frame,\n      window: {\n        min: Types.Timing.MicroSeconds(0),\n        max: Types.Timing.MicroSeconds(0),\n        range: Types.Timing.MicroSeconds(0),\n      },\n    };\n  });\n\n  // If this window was already created, do nothing.\n  if (rendererProcessInfo.window.min !== Types.Timing.MicroSeconds(0)) {\n    return;\n  }\n\n  // For now we store the time of the event as the min. In the finalize we step\n  // through each of these windows and update their max and range values.\n  rendererProcessInfo.window.min = event.ts;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Meta Handler is not initialized');\n  }\n\n  // If there is a timestamp (which meta events do not have), and the event does\n  // not end with ::UMA then it, and the event is in the set of valid phases,\n  // then it should be included for the purposes of calculating the trace bounds.\n  // The UMA events in particular seem to be reported on page unloading, which\n  // often extends the bounds of the trace unhelpfully.\n  if (event.ts !== 0 && !event.name.endsWith('::UMA') && eventPhasesOfInterestForTraceBounds.has(event.ph)) {\n    traceBounds.min = Types.Timing.MicroSeconds(Math.min(event.ts, traceBounds.min));\n    const eventDuration = event.dur || Types.Timing.MicroSeconds(0);\n    traceBounds.max = Types.Timing.MicroSeconds(Math.max(event.ts + eventDuration, traceBounds.max));\n  }\n\n  if (Types.TraceEvents.isProcessName(event) &&\n      (event.args.name === 'Browser' || event.args.name === 'HeadlessBrowser')) {\n    browserProcessId = event.pid;\n    return;\n  }\n\n  if (Types.TraceEvents.isProcessName(event) && (event.args.name === 'Gpu' || event.args.name === 'GPU Process')) {\n    gpuProcessId = event.pid;\n    return;\n  }\n\n  if (Types.TraceEvents.isThreadName(event) && event.args.name === 'CrGpuMain') {\n    gpuThreadId = event.tid;\n    return;\n  }\n\n  if (Types.TraceEvents.isThreadName(event) && event.args.name === 'CrBrowserMain') {\n    browserThreadId = event.tid;\n  }\n\n  if (Types.TraceEvents.isTraceEventMainFrameViewport(event) && viewportRect === null) {\n    const rectAsArray = event.args.data.viewport_rect;\n    const viewportX = rectAsArray[0];\n    const viewportY = rectAsArray[1];\n    const viewportWidth = rectAsArray[2];\n    const viewportHeight = rectAsArray[5];\n    viewportRect = new DOMRect(viewportX, viewportY, viewportWidth, viewportHeight);\n  }\n\n  // The TracingStartedInBrowser event includes the data on which frames are\n  // in scope at the start of the trace. We use this to identify the frame with\n  // no parent, i.e. the top level frame.\n  if (Types.TraceEvents.isTraceEventTracingStartedInBrowser(event)) {\n    traceStartedTime = event.ts;\n\n    if (!event.args.data) {\n      throw new Error('No frames found in trace data');\n    }\n\n    for (const frame of (event.args.data.frames ?? [])) {\n      updateRendererProcessByFrame(event, frame);\n\n      if (frame.parent) {\n        continue;\n      }\n\n      mainFrameId = frame.frame;\n      mainFrameURL = frame.url;\n      topLevelRendererIds.add(frame.processId);\n    }\n    return;\n  }\n\n  // FrameCommittedInBrowser events tell us information about each frame\n  // and we use these to track how long each individual renderer is active\n  // for. We track all renderers here (top level and those in frames), but\n  // for convenience we also populate a set of top level renderer IDs.\n  if (Types.TraceEvents.isTraceEventFrameCommittedInBrowser(event)) {\n    const frame = event.args.data;\n    if (!frame) {\n      return;\n    }\n\n    updateRendererProcessByFrame(event, frame);\n\n    if (frame.parent) {\n      return;\n    }\n\n    topLevelRendererIds.add(frame.processId);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventCommitLoad(event)) {\n    const frameData = event.args.data;\n    if (!frameData) {\n      return;\n    }\n\n    const {frame, name, url} = frameData;\n    updateRendererProcessByFrame(event, {processId: event.pid, frame, name, url});\n    return;\n  }\n\n  // Track all threads based on the process & thread IDs.\n  if (Types.TraceEvents.isThreadName(event)) {\n    const threads = Platform.MapUtilities.getWithDefault(threadsInProcess, event.pid, () => new Map());\n    threads.set(event.tid, event);\n    return;\n  }\n\n  // Track all navigation events. Note that there can be navigation start events\n  // but where the documentLoaderURL is empty. As far as the trace rendering is\n  // concerned, these events are noise so we filter them out here.\n  if (Types.TraceEvents.isTraceEventNavigationStartWithURL(event) && event.args.data) {\n    const navigationId = event.args.data.navigationId;\n    if (navigationsByNavigationId.has(navigationId)) {\n      throw new Error('Found multiple navigation start events with the same navigation ID.');\n    }\n    navigationsByNavigationId.set(navigationId, event);\n\n    const frameId = event.args.frame;\n    const existingFrameNavigations = navigationsByFrameId.get(frameId) || [];\n    existingFrameNavigations.push(event);\n    navigationsByFrameId.set(frameId, existingFrameNavigations);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Handler is not initialized');\n  }\n\n  traceBounds.min = traceStartedTime;\n  traceBounds.range = Types.Timing.MicroSeconds(traceBounds.max - traceBounds.min);\n\n  // If we go from foo.com to example.com we will get a new renderer, and\n  // therefore the \"top level renderer\" will have a different PID as it has\n  // changed. Here we step through each renderer process and updated its window\n  // bounds, such that we end up with the time ranges in the trace for when\n  // each particular renderer started and stopped being the main renderer\n  // process.\n  for (const [, processWindows] of rendererProcessesByFrameId) {\n    const processWindowValues = [...processWindows.values()];\n    for (let i = 0; i < processWindowValues.length; i++) {\n      const currentWindow = processWindowValues[i];\n      const nextWindow = processWindowValues[i + 1];\n\n      // For the last window we set its max to be positive infinity.\n      // TODO: Move the trace bounds handler into meta so we can clamp first and last windows.\n      if (!nextWindow) {\n        currentWindow.window.max = Types.Timing.MicroSeconds(traceBounds.max);\n        currentWindow.window.range = Types.Timing.MicroSeconds(traceBounds.max - currentWindow.window.min);\n      } else {\n        currentWindow.window.max = Types.Timing.MicroSeconds(nextWindow.window.min - 1);\n        currentWindow.window.range = Types.Timing.MicroSeconds(currentWindow.window.max - currentWindow.window.min);\n      }\n    }\n  }\n\n  // Frame ids which we didn't register using either the TracingStartedInBrowser or\n  // the FrameCommittedInBrowser events are considered noise, so we filter them out, as well\n  // as the navigations that belong to such frames.\n  for (const [frameId, navigations] of navigationsByFrameId) {\n    // The frames in the rendererProcessesByFrameId map come only from the\n    // TracingStartedInBrowser and FrameCommittedInBrowser events, so we can use it as point\n    // of comparison to determine if a frameId should be discarded.\n    if (rendererProcessesByFrameId.has(frameId)) {\n      continue;\n    }\n    navigationsByFrameId.delete(frameId);\n    for (const navigation of navigations) {\n      if (!navigation.args.data) {\n        continue;\n      }\n      navigationsByNavigationId.delete(navigation.args.data.navigationId);\n    }\n  }\n\n  handlerState = HandlerState.FINALIZED;\n}\n\ntype MetaHandlerData = {\n  traceBounds: Types.Timing.TraceWindow,\n  browserProcessId: Types.TraceEvents.ProcessID,\n  browserThreadId: Types.TraceEvents.ThreadID,\n  gpuProcessId: Types.TraceEvents.ProcessID,\n  gpuThreadId?: Types.TraceEvents.ThreadID,\n  viewportRect?: DOMRect,\n              navigationsByFrameId: Map<string, Types.TraceEvents.TraceEventNavigationStart[]>,\n              navigationsByNavigationId: Map<string, Types.TraceEvents.TraceEventNavigationStart>,\n              threadsInProcess:\n                  Map<Types.TraceEvents.ProcessID,\n                      Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>,\n              mainFrameId: string,\n              mainFrameURL: string,\n              rendererProcessesByFrame:\n                  Map<string,\n                      Map<Types.TraceEvents.ProcessID,\n                          {frame: Types.TraceEvents.TraceFrame, window: Types.Timing.TraceWindow}>>,\n              topLevelRendererIds: Set<Types.TraceEvents.ProcessID>,\n};\n\nexport function data(): MetaHandlerData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Meta Handler is not finalized');\n  }\n\n  return {\n    traceBounds: {...traceBounds},\n    browserProcessId,\n    browserThreadId,\n    gpuProcessId,\n    gpuThreadId: gpuThreadId === Types.TraceEvents.ThreadID(-1) ? undefined : gpuThreadId,\n    viewportRect: viewportRect || undefined,\n    mainFrameId,\n    mainFrameURL,\n    navigationsByFrameId: new Map(navigationsByFrameId),\n    navigationsByNavigationId: new Map(navigationsByNavigationId),\n    threadsInProcess: new Map(threadsInProcess),\n    rendererProcessesByFrame: new Map(rendererProcessesByFrameId),\n    topLevelRendererIds: new Set(topLevelRendererIds),\n  };\n}\n"]}