{"version":3,"file":"CoverageModel.js","sourceRoot":"","sources":["../../../../../../front_end/panels/coverage/CoverageModel.ts"],"names":[],"mappings":"AAAA,gEAAgE;AAChE,yEAAyE;AACzE,6BAA6B;AAG7B,OAAO,KAAK,MAAM,MAAM,6BAA6B,CAAC;AACtD,OAAO,KAAK,QAAQ,MAAM,iCAAiC,CAAC;AAC5D,OAAO,KAAK,GAAG,MAAM,uBAAuB,CAAC;AAC7C,OAAO,KAAK,SAAS,MAAM,uCAAuC,CAAC;AAenE,wDAAwD;AACxD,+CAA+C;AAC/C,MAAM,CAAN,IAAY,MAGX;AAHD,WAAY,MAAM;IAChB,6CAAmC,CAAA;IACnC,yCAA+B,CAAA;AACjC,CAAC,EAHW,MAAM,KAAN,MAAM,QAGjB;AAOD,MAAM,0BAA0B,GAAW,GAAG,CAAC;AAO/C,MAAM,OAAO,aAAc,SAAQ,GAAG,CAAC,QAAQ,CAAC,QAAoB;IAC1D,gBAAgB,CAA6C;IAC7D,QAAQ,CAA6B;IACrC,aAAa,CAAuC;IACpD,aAAa,CAAwD;IACrE,yBAAyB,CAA+D;IACxF,mBAAmB,CAAc;IACjC,eAAe,CAAkB;IACjC,SAAS,CAAc;IACvB,kBAAkB,CAAqB;IACvC,2BAA2B,CAAe;IAC1C,SAAS,CAAkD;IAC3D,UAAU,CAAwC;IAClD,yBAAyB,CAAe;IAEhD,YAAY,MAAyB;QACnC,KAAK,CAAC,MAAM,CAAC,CAAC;QACd,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,CAAC;QAC5E,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACpD,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QAEnE,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,yBAAyB,GAAG,IAAI,GAAG,EAAE,CAAC;QAE3C,0FAA0F;QAC1F,0FAA0F;QAC1F,qFAAqF;QACrF,IAAI,CAAC,mBAAmB,GAAG,IAAI,GAAG,EAAE,CAAC;QAErC,IAAI,CAAC,eAAe,wCAAyB,CAAC;QAC9C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;QAC/B,IAAI,CAAC,2BAA2B,GAAG,KAAK,CAAC;QACzC,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;QACrB,IAAI,CAAC,yBAAyB,GAAG,KAAK,CAAC;IACzC,CAAC;IAED,KAAK,CAAC,KAAK,CAAC,kBAA2B;QACrC,IAAI,IAAI,CAAC,eAAe,0CAA2B,EAAE;YACnD,MAAM,KAAK,CAAC,oDAAoD,CAAC,CAAC;SACnE;QACD,MAAM,QAAQ,GAAG,EAAE,CAAC;QACpB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,yDAAyD;YACzD,6CAA6C;YAC7C,IAAI,CAAC,QAAQ,EAAE,CAAC;YAEhB,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,eAAe,EAAE,IAAI,CAAC,qBAAqB,EAAE,IAAI,CAAC,CAAC;YACtG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE,CAAC,CAAC;SAC9C;QACD,IAAI,IAAI,CAAC,gBAAgB,EAAE;YACzB,QAAQ,CAAC,IAAI,CACT,IAAI,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,kBAAkB,EAAE,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACjH;QAED,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAC5B,OAAO,OAAO,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACzD,CAAC;IAED,0BAA0B,CAAC,SAAiB,EAAE,QAAgB,EAAE,YAAgD;QAE9G,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACxC,KAAK,IAAI,CAAC,0BAA0B,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;IAChE,CAAC;IAED,KAAK,CAAC,IAAI;QACR,MAAM,IAAI,CAAC,WAAW,EAAE,CAAC;QACzB,MAAM,QAAQ,GAAG,EAAE,CAAC;QACpB,IAAI,IAAI,CAAC,gBAAgB,EAAE;YACzB,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,mBAAmB,EAAE,CAAC,CAAC;SAC5D;QACD,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,CAAC,CAAC;YAC5C,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,eAAe,EAAE,IAAI,CAAC,qBAAqB,EAAE,IAAI,CAAC,CAAC;SAC1G;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAC9B,CAAC;IAED,KAAK;QACH,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,yBAAyB,GAAG,IAAI,GAAG,EAAE,CAAC;QAC3C,IAAI,CAAC,mBAAmB,GAAG,IAAI,GAAG,EAAE,CAAC;QACrC,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;IACtD,CAAC;IAED,KAAK,CAAC,YAAY;QAChB,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,eAAe,0CAA2B,EAAE;YAC9E,OAAO;SACR;QACD,MAAM,IAAI,CAAC,QAAQ,EAAE,CAAC;IACxB,CAAC;IAEO,KAAK,CAAC,QAAQ;QACpB,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QACjD,MAAM,IAAI,CAAC,kBAAkB,CAAC;QAC9B,IAAI,IAAI,CAAC,eAAe,0CAA2B,IAAI,IAAI,CAAC,yBAAyB,EAAE;YACrF,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,0BAA0B,CAAC,CAAC;SACvF;IACH,CAAC;IAED,KAAK,CAAC,WAAW;QACf,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,MAAM,IAAI,CAAC,kBAAkB,CAAC;QAC9B,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;QAC/B,0CAA0C;QAC1C,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC;IAC/B,CAAC;IAEO,KAAK,CAAC,eAAe;QAC3B,IAAI,IAAI,CAAC,eAAe,gDAA8B,IAAI,CAAC,IAAI,CAAC,yBAAyB,EAAE;YACzF,OAAO;SACR;QACD,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC;QAC7C,sEAAsE;QACtE,oEAAoE;QACpE,OAAO,CAAC,MAAM,CACV,IAAI,CAAC,eAAe,gDAA8B,IAAI,OAAO,CAAC,IAAI,CAAC,yBAAyB,CAAC,EAC7F,4CAA4C,CAAC,CAAC;QAClD,IAAI,OAAO,CAAC,MAAM,EAAE;YAClB,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;SAChE;IACH,CAAC;IAEO,UAAU;QAChB,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC7B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;SACvB;IACH,CAAC;IAED;;;OAGG;IACM,KAAK,CAAC,eAAe,CAAC,MAAe;QAC5C,IAAI,IAAI,CAAC,eAAe,0CAA2B,EAAE;YACnD,OAAO;SACR;QACD,IAAI,CAAC,eAAe,gDAA6B,CAAC;QAClD,IAAI,MAAM,KAAK,sBAAsB,EAAE;YACrC,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAC;YACtC,kEAAkE;YAClE,OAAO;SACR;QACD,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3B,MAAM,IAAI,CAAC,WAAW,EAAE,CAAC;YACzB,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC;SACzC;IACH,CAAC;IAEQ,KAAK,CAAC,YAAY,CAAC,OAAgB;QAC1C,IAAI,CAAC,eAAe,8CAA4B,CAAC;IACnD,CAAC;IAEQ,KAAK,CAAC,WAAW;IAC1B,CAAC;IAED;;;OAGG;IACM,KAAK,CAAC,eAAe;QAC5B,IAAI,CAAC,eAAe,wCAAyB,CAAC;QAC9C,IAAI,CAAC,yBAAyB,GAAG,KAAK,CAAC;QACvC,IAAI,IAAI,CAAC,2BAA2B,EAAE;YACpC,IAAI,CAAC,2BAA2B,GAAG,KAAK,CAAC;YACzC,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;SAC3B;IACH,CAAC;IAED,OAAO;QACL,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC;IACjD,CAAC;IAED,iBAAiB,CAAC,GAAoC;QACpD,OAAO,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC;IAC7C,CAAC;IAED,aAAa,CAAC,eAA0D,EAAE,WAAmB,EAAE,SAAiB;QAE9G,MAAM,YAAY,GAAG,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;QACzE,OAAO,YAAY,IAAI,YAAY,CAAC,aAAa,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;IAC5E,CAAC;IAEO,QAAQ;QACd,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,yBAAyB,CAAC,MAAM,EAAE,EAAE;YAC3D,IAAI,KAAK,CAAC,IAAI,EAAE,6BAAqB,EAAE;gBACrC,SAAS;aACV;YACD,MAAM,eAAe,GAAG,KAAK,CAAC,kBAAkB,EAAiD,CAAC;YAClG,IAAI,CAAC,yBAAyB,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;YACvD,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;YACrD,IAAI,CAAC,QAAQ,EAAE;gBACb,SAAS;aACV;YACD,MAAM,GAAG,GAAG,GAAG,eAAe,CAAC,SAAS,IAAI,eAAe,CAAC,WAAW,EAAE,CAAC;YAC1E,QAAQ,CAAC,mBAAmB,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YACzC,IAAI,QAAQ,CAAC,eAAe,EAAE,KAAK,CAAC,EAAE;gBACpC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;aACxC;SACF;QAED,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,KAAK,MAAM,gBAAgB,IAAI,IAAI,CAAC,QAAQ,CAAC,uBAAuB,EAAE,EAAE;gBACtE,IAAI,CAAC,0BAA0B,CAAC,gBAAgB,CAAC,CAAC;aACnD;SACF;IACH,CAAC;IAEO,KAAK,CAAC,eAAe;QAC3B,MAAM,CAAC,UAAU,EAAE,SAAS,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,eAAe,EAAE,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;QACnG,OAAO,CAAC,GAAG,UAAU,EAAE,GAAG,SAAS,CAAC,CAAC;IACvC,CAAC;IAEO,KAAK,CAAC,cAAc;QAC1B,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;YAC1B,OAAO,EAAE,CAAC;SACX;QACD,MAAM,EAAC,QAAQ,EAAE,SAAS,EAAC,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,mBAAmB,EAAE,CAAC;QAChF,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACxC,OAAO,IAAI,CAAC,0BAA0B,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;IAC9D,CAAC;IAED,sBAAsB;QACpB,OAAO,IAAI,CAAC,mBAAmB,CAAC;IAClC,CAAC;IAEO,KAAK,CAAC,0BAA0B,CACpC,oBAAwD,EAAE,cAAsB;QAClF,IAAI,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;YACnC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAC,eAAe,EAAE,oBAAoB,EAAE,KAAK,EAAE,cAAc,EAAC,CAAC,CAAC;SACrF;QACD,IAAI,IAAI,CAAC,eAAe,0CAA2B,EAAE;YACnD,OAAO,EAAE,CAAC;SACX;QACD,MAAM,oBAAoB,GAAG,CAAC,CAAkB,EAAE,CAAkB,EAAU,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;QACnG,MAAM,OAAO,GAAG,EAAE,CAAC;QACnB,KAAK,MAAM,EAAC,eAAe,EAAE,KAAK,EAAC,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,oBAAoB,CAAC,EAAE;YAChF,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC,CAAC;SAC9D;QACD,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,OAAO,OAAO,CAAC,IAAI,EAAE,CAAC;IACxB,CAAC;IAED,KAAK,CAAC,gBAAgB;QACpB,KAAK,IAAI,CAAC,0BAA0B,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IAC9C,CAAC;IAEO,iBAAiB,CAAC,eAAmD,EAAE,KAAa;QAC1F,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,OAAO,EAAE,CAAC;SACX;QACD,MAAM,cAAc,GAAG,EAAE,CAAC;QAC1B,KAAK,MAAM,KAAK,IAAI,eAAe,EAAE;YACnC,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC9D,IAAI,CAAC,MAAM,EAAE;gBACX,SAAS;aACV;YAED,MAAM,MAAM,GAAG,EAAE,CAAC;YAClB,IAAI,IAAI,kCAA0B,CAAC;YACnC,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC,SAAS,EAAE;gBAClC,8EAA8E;gBAC9E,iFAAiF;gBACjF,iFAAiF;gBACjF,eAAe;gBACf,IAAI,IAAI,CAAC,eAAe,KAAK,KAAK,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;oBAC1F,IAAI,8CAAsC,CAAC;iBAC5C;gBACD,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;oBAC/B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACpB;aACF;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAC7B,MAAM,EAAE,MAAM,CAAC,aAAa,EAAE,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,YAAY,EAAE,MAAM,EAAE,IAAoB,EAAE,KAAK,CAAC,CAAC;YAC/G,IAAI,QAAQ,EAAE;gBACZ,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aAC/B;SACF;QACD,OAAO,cAAc,CAAC;IACxB,CAAC;IAEO,qBAAqB,CACzB,KAAuF;QACzF,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC9C,CAAC;IAEO,KAAK,CAAC,eAAe;QAC3B,oDAAoD;QACpD,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,eAAe,0CAA2B,EAAE;YACrE,OAAO,EAAE,CAAC;SACX;QACD,MAAM,EAAC,QAAQ,EAAE,SAAS,EAAC,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,iBAAiB,EAAE,CAAC;QACtE,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACxC,OAAO,IAAI,CAAC,2BAA2B,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;IAC/D,CAAC;IAEO,KAAK,CAAC,2BAA2B,CAAC,oBAA8C,EAAE,cAAsB;QAE9G,IAAI,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;YACnC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAC,eAAe,EAAE,oBAAoB,EAAE,KAAK,EAAE,cAAc,EAAC,CAAC,CAAC;SACtF;QACD,IAAI,IAAI,CAAC,eAAe,0CAA2B,EAAE;YACnD,OAAO,EAAE,CAAC;SACX;QACD,MAAM,oBAAoB,GAAG,CAAC,CAAkB,EAAE,CAAkB,EAAU,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;QACnG,MAAM,OAAO,GAAG,EAAE,CAAC;QACnB,KAAK,MAAM,EAAC,eAAe,EAAE,KAAK,EAAC,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,oBAAoB,CAAC,EAAE;YACjF,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC,CAAC;SAC/D;QACD,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;QACrB,OAAO,OAAO,CAAC,IAAI,EAAE,CAAC;IACxB,CAAC;IAEO,kBAAkB,CAAC,aAAuC,EAAE,KAAa;QAC/E,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClB,OAAO,EAAE,CAAC;SACX;QACD,MAAM,cAAc,GAAG,EAAE,CAAC;QAC1B,MAAM,iBAAiB,GAAG,IAAI,GAAG,EAAgE,CAAC;QAClG,KAAK,MAAM,IAAI,IAAI,aAAa,EAAE;YAChC,MAAM,gBAAgB,GAAG,IAAI,CAAC,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAChF,IAAI,CAAC,gBAAgB,EAAE;gBACrB,SAAS;aACV;YACD,IAAI,MAAM,GAAG,iBAAiB,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;YACrD,IAAI,CAAC,MAAM,EAAE;gBACX,MAAM,GAAG,EAAE,CAAC;gBACZ,iBAAiB,CAAC,GAAG,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAC;aACjD;YACD,MAAM,CAAC,IAAI,CAAC,EAAC,WAAW,EAAE,IAAI,CAAC,WAAW,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAC,CAAC,CAAC;SACnG;QACD,KAAK,MAAM,KAAK,IAAI,iBAAiB,EAAE;YACrC,MAAM,gBAAgB,GAAG,KAAK,CAAC,CAAC,CAAgD,CAAC;YACjF,MAAM,MAAM,GAAG,KAAK,CAAC,CAAC,CAAoB,CAAC;YAC3C,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAC7B,gBAAgB,EAAE,gBAAgB,CAAC,aAAa,EAAE,gBAAgB,CAAC,SAAS,EAAE,gBAAgB,CAAC,WAAW,EAC1G,MAAM,4BAAoB,KAAK,CAAC,CAAC;YACrC,IAAI,QAAQ,EAAE;gBACZ,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aAC/B;SACF;QACD,OAAO,cAAc,CAAC;IACxB,CAAC;IAEO,MAAM,CAAC,yBAAyB,CAAC,MAAuB,EAAE,KAAa;QAC7E,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,GAAG,CAAC,CAAC,WAAW,CAAC,CAAC;QAErD,MAAM,MAAM,GAAsB,EAAE,CAAC;QACrC,MAAM,KAAK,GAAG,EAAE,CAAC;QACjB,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;YAC1B,IAAI,GAAG,GAAkB,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACjD,OAAO,GAAG,IAAI,GAAG,CAAC,SAAS,IAAI,KAAK,CAAC,WAAW,EAAE;gBAChD,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;gBACjC,KAAK,CAAC,GAAG,EAAE,CAAC;gBACZ,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;aAC/B;YACD,MAAM,CAAC,KAAK,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/C,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACnB;QAED,KAAK,IAAI,GAAG,GAAG,KAAK,CAAC,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,KAAK,CAAC,GAAG,EAAE,EAAE;YAClD,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;SAClC;QAED,SAAS,MAAM,CAAC,GAAW,EAAE,KAAa;YACxC,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACvC,IAAI,IAAI,EAAE;gBACR,IAAI,IAAI,CAAC,GAAG,KAAK,GAAG,EAAE;oBACpB,OAAO;iBACR;gBACD,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK,EAAE;oBACxB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;oBACf,OAAO;iBACR;aACF;YACD,MAAM,CAAC,IAAI,CAAC,EAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAC,CAAC,CAAC;QACtD,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAEO,0BAA0B,CAAC,gBAA6D;QAC9F,IAAI,CAAC,WAAW,CACZ,gBAAgB,EAAE,gBAAgB,CAAC,aAAa,EAAE,gBAAgB,CAAC,SAAS,EAAE,gBAAgB,CAAC,WAAW,EAAE,EAAE,4BAC5F,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;IACpC,CAAC;IAEO,WAAW,CACf,eAA0D,EAAE,aAAqB,EAAE,SAAiB,EACpG,WAAmB,EAAE,MAAuB,EAAE,IAAkB,EAAE,KAAa;QACjF,MAAM,GAAG,GAAG,eAAe,CAAC,UAAU,EAAE,CAAC;QACzC,IAAI,CAAC,GAAG,EAAE;YACR,OAAO,IAAI,CAAC;SACb;QACD,IAAI,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC9C,IAAI,gBAAgB,GAAG,KAAK,CAAC;QAC7B,IAAI,CAAC,WAAW,EAAE;YAChB,gBAAgB,GAAG,IAAI,CAAC;YACxB,WAAW,GAAG,IAAI,eAAe,CAAC,GAAG,CAAC,CAAC;YACvC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;SAC1C;QAED,MAAM,YAAY,GAAG,WAAW,CAAC,WAAW,CAAC,eAAe,EAAE,aAAa,EAAE,SAAS,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;QAC3G,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;QAClE,MAAM,QAAQ,GAAG,aAAa,CAAC,yBAAyB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QACxE,MAAM,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC3C,IAAI,IAAI,IAAI,IAAI,CAAC,GAAG,GAAG,aAAa,EAAE;YACpC,QAAQ,CAAC,IAAI,CAAC,EAAC,GAAG,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,EAAC,CAAC,CAAC;SAC7D;QACD,MAAM,aAAa,GAAG,YAAY,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;QAC3D,IAAI,CAAC,gBAAgB,IAAI,aAAa,KAAK,CAAC,EAAE;YAC5C,OAAO,IAAI,CAAC;SACb;QACD,WAAW,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;QACzC,OAAO,YAAY,CAAC;IACtB,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,GAAwC;QACzD,MAAM,MAAM,GAA+E,EAAE,CAAC;QAC9F,MAAM,iBAAiB,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;QACvE,KAAK,MAAM,UAAU,IAAI,iBAAiB,EAAE;YAC1C,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;YACnD,IAAI,CAAC,OAAO,EAAE;gBACZ,SAAS;aACV;YACD,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC;YAC1B,IAAI,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,GAAG,CAAC,UAAU,CAAC,qBAAqB,CAAC,EAAE;gBAC3E,SAAS;aACV;YACD,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,OAAO,CAAC,gBAAgB,EAAE,CAAC,CAAC;SAClD;QACD,MAAM,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;QACtD,KAAK,GAAG,CAAC,KAAK,EAAE,CAAC;IACnB,CAAC;CACF;AAED,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,aAAa,EAAE,EAAC,YAAY,EAAE,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,EAAE,KAAK,EAAC,CAAC,CAAC;AAQ5G,SAAS,eAAe,CAAC,CAAS,EAAE,CAAS;IAC3C,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACnC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACnC,OAAO,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC;QAC1D,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;AAC5D,CAAC;AAED,MAAM,OAAO,eAAgB,SAAQ,MAAM,CAAC,aAAa,CAAC,aAAyC;IAChF,WAAW,CAAkC;IACtD,sBAAsB,CAA4B;IAClD,YAAY,CAAS;IACrB,gBAAgB,CAAS;IACzB,YAAY,CAAgB;IAC5B,uBAAuB,CAAU;IAEzC,YAAY,GAAoC;QAC9C,KAAK,EAAE,CAAC;QAER,IAAI,CAAC,WAAW,GAAG,GAAG,CAAC;QACvB,IAAI,CAAC,sBAAsB,GAAG,IAAI,GAAG,EAAE,CAAC;QACxC,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;QACtB,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;QAC1B,IAAI,CAAC,uBAAuB,GAAG,KAAK,CAAC;IACvC,CAAC;IAED,GAAG;QACD,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,IAAI;QACF,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED,IAAI;QACF,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED,QAAQ;QACN,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED,UAAU;QACR,OAAO,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,gBAAgB,CAAC;IACnD,CAAC;IAED,cAAc;QACZ,8DAA8D;QAC9D,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,EAAE;YAC3B,OAAO,CAAC,CAAC;SACV;QACD,OAAO,IAAI,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;IACvC,CAAC;IAED,gBAAgB;QACd,8DAA8D;QAC9D,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,EAAE;YAC3B,OAAO,GAAG,CAAC;SACZ;QACD,OAAO,IAAI,CAAC,UAAU,EAAE,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;IACzC,CAAC;IAED,eAAe;QACb,OAAO,IAAI,CAAC,uBAAuB,CAAC;IACtC,CAAC;IAED,OAAO;QACL,OAAO,IAAI,CAAC,sBAAsB,CAAC,MAAM,EAAE,CAAC;IAC9C,CAAC;IAED,eAAe;QACb,OAAO,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC;IAC1C,CAAC;IAED,mBAAmB,CAAC,GAAW,EAAE,KAAmB;QAClD,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;YAC5C,OAAO;SACR;QACD,IAAI,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,EAAE,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;IAC1D,CAAC;IAED,UAAU,CAAC,QAAgB,EAAE,IAAY;QACvC,IAAI,CAAC,gBAAgB,IAAI,QAAQ,CAAC;QAClC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC;QAE1B,IAAI,QAAQ,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,EAAE;YAChC,IAAI,CAAC,wBAAwB,CAAC,eAAe,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;SACpE;IACH,CAAC;IAED,WAAW,CACP,eAA0D,EAAE,aAAqB,EAAE,UAAkB,EACrG,YAAoB,EAAE,IAAkB;QAC1C,MAAM,GAAG,GAAG,GAAG,UAAU,IAAI,YAAY,EAAE,CAAC;QAC5C,IAAI,KAAK,GAAG,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAEjD,IAAI,CAAC,IAAI,kCAA0B,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE;YACzE,IAAI,CAAC,uBAAuB,GAAI,eAAqC,CAAC,eAAe,EAAE,CAAC;SACzF;QACD,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC;QAE1B,IAAI,KAAK,EAAE;YACT,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;YAC5B,OAAO,KAAK,CAAC;SACd;QAED,IAAI,CAAC,IAAI,kCAA0B,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE;YACzE,IAAI,CAAC,uBAAuB,GAAI,eAAqC,CAAC,eAAe,EAAE,CAAC;SACzF;QAED,KAAK,GAAG,IAAI,YAAY,CAAC,eAAe,EAAE,aAAa,EAAE,UAAU,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;QACzF,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QAC5C,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC;QAElC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,KAAK,CAAC,WAAW;QACf,+EAA+E;QAC/E,IAAI,WAAW,GAAG,KAAK,CAAC;QACxB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,sBAAsB,CAAC,MAAM,EAAE,EAAE;YACvD,MAAM,EAAC,UAAU,EAAE,YAAY,EAAC,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;YACrD,IAAI,UAAU,IAAI,YAAY,EAAE;gBAC9B,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;gBAC3B,MAAM;aACP;SACF;QAED,IAAI,CAAC,WAAW,EAAE;YAChB,OAAO,IAAI,CAAC;SACb;QACD,MAAM,QAAQ,GAAG,GAAG,CAAC,iBAAiB,CAAC,iBAAiB,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;QAC7E,IAAI,CAAC,QAAQ,EAAE;YACb,OAAO,IAAI,CAAC;SACb;QACD,MAAM,OAAO,GAAG,CAAC,MAAM,QAAQ,CAAC,cAAc,EAAE,CAAC,CAAC,OAAO,CAAC;QAC1D,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC;IAChD,CAAC;IAED,+BAA+B,CAAC,QAA6B;QAC3D,MAAM,sBAAsB,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QACpG,MAAM,KAAK,GAAmB,EAAC,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,IAAI,EAAE,QAAQ,CAAC,KAAK,EAAE,EAAC,CAAC;QACpF,KAAK,MAAM,OAAO,IAAI,sBAAsB,EAAE;YAC5C,MAAM,IAAI,GAAG,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACtD,IAAI,CAAC,IAAI,EAAE;gBACT,SAAS;aACV;YACD,MAAM,EAAC,UAAU,EAAE,YAAY,EAAC,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;YACrD,MAAM,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,kBAAkB,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACpF,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC;SACpD;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,KAAK,CAAC,8BAA8B;QAClC,MAAM,sBAAsB,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QACpG,MAAM,MAAM,GAAG,EAAE,CAAC;QAClB,KAAK,MAAM,OAAO,IAAI,sBAAsB,EAAE;YAC5C,MAAM,IAAI,GAAG,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACtD,IAAI,CAAC,IAAI,EAAE;gBACT,SAAS;aACV;YACD,MAAM,KAAK,GAAmB;gBAC5B,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE;gBACf,MAAM,EAAE,IAAI,CAAC,eAAe,EAAE;gBAC9B,IAAI,EAAE,CAAC,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAC,cAAc,EAAE,CAAC,CAAC,OAAO;aACjE,CAAC;YACF,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACpB;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,gBAAgB;QACpB,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,EAAE,CAAC;QAE1C,wFAAwF;QACxF,IAAI,QAAQ,EAAE;YACZ,OAAO,CAAC,MAAM,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC/D;QAED,yCAAyC;QACzC,OAAO,IAAI,CAAC,8BAA8B,EAAE,CAAC;IAC/C,CAAC;CACF;AAED,WAAiB,eAAe;IAC9B,wDAAwD;IACxD,+CAA+C;IAC/C,IAAY,MAEX;IAFD,WAAY,MAAM;QAChB,uCAA6B,CAAA;IAC/B,CAAC,EAFW,MAAM,GAAN,sBAAM,KAAN,sBAAM,QAEjB;AAKH,CAAC,EAVgB,eAAe,KAAf,eAAe,QAU/B;AAED,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,SAA4B,EAAE,SAA4B,EAAqB,EAAE;IAC7G,MAAM,MAAM,GAAsB,EAAE,CAAC;IAErC,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,OAAO,MAAM,GAAG,SAAS,CAAC,MAAM,IAAI,MAAM,GAAG,SAAS,CAAC,MAAM,EAAE;QAC7D,MAAM,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;QAC5B,MAAM,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;QAC5B,MAAM,KAAK,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;QAC9C,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;QACnC,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACvC,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;QACzC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK,EAAE;YACzD,MAAM,CAAC,IAAI,CAAC,EAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAC,CAAC,CAAC;SACrD;aAAM;YACL,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;SAChB;QACD,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,EAAE;YAClB,MAAM,EAAE,CAAC;SACV;QACD,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,EAAE;YAClB,MAAM,EAAE,CAAC;SACV;KACF;IAED,OAAO,MAAM,GAAG,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE;QAC1C,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;KAChC;IACD,OAAO,MAAM,GAAG,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE;QAC1C,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;KAChC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEF,MAAM,OAAO,YAAY;IACf,eAAe,CAA4C;IAC3D,IAAI,CAAS;IACb,QAAQ,CAAS;IACjB,gBAAgB,CAAsB;IACtC,UAAU,CAAS;IACnB,YAAY,CAAS;IACrB,YAAY,CAAe;IAC3B,QAAQ,CAAoB;IAEpC,YACI,eAA0D,EAAE,IAAY,EAAE,UAAkB,EAC5F,YAAoB,EAAE,IAAkB;QAC1C,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;QAClB,IAAI,CAAC,gBAAgB,GAAG,IAAI,GAAG,EAAE,CAAC;QAClC,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAEzB,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;IACrB,CAAC;IAED,kBAAkB;QAChB,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAED,GAAG;QACD,OAAO,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,CAAC;IAC3C,CAAC;IAED,IAAI;QACF,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED,eAAe,CAAC,IAAkB;QAChC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC;IAC5B,CAAC;IAED,UAAU;QACR,OAAO,EAAC,UAAU,EAAE,IAAI,CAAC,UAAU,EAAE,YAAY,EAAE,IAAI,CAAC,YAAY,EAAC,CAAC;IACxE,CAAC;IAED;;OAEG;IACH,aAAa,CAAC,QAA2B;QACvC,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC;QAClC,IAAI,CAAC,QAAQ,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACvD,IAAI,CAAC,WAAW,EAAE,CAAC;QACnB,OAAO,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC;IACrC,CAAC;IAED,eAAe;QACb,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED,OAAO;QACL,OAAO,IAAI,CAAC,IAAI,CAAC;IACnB,CAAC;IAED,WAAW;QACT,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED,aAAa,CAAC,KAAa,EAAE,GAAW;QACtC,IAAI,KAAK,GAAG,QAAQ,CAAC,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE,CAAC,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;QACpH,OAAO,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,EAAE,KAAK,EAAE;YAC9E,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE;gBAC9B,OAAO,IAAI,CAAC;aACb;SACF;QACD,OAAO,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC;IAC7E,CAAC;IAEO,WAAW;QACjB,IAAI,CAAC,gBAAgB,GAAG,IAAI,GAAG,EAAE,CAAC;QAClC,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;QAElB,IAAI,IAAI,GAAG,CAAC,CAAC;QACb,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE;YACnC,IAAI,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAC7D,IAAI,aAAa,KAAK,SAAS,EAAE;gBAC/B,aAAa,GAAG,CAAC,CAAC;aACnB;YAED,IAAI,OAAO,CAAC,KAAK,EAAE;gBACjB,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,GAAG,IAAI,CAAC;gBAChC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC;gBACtB,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,aAAa,GAAG,IAAI,CAAC,CAAC;aAChE;YACD,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC;SACpB;IACH,CAAC;IAED,eAAe,CAAC,SAAiB,CAAC;QAChC,MAAM,MAAM,GAAG,EAAE,CAAC;QAClB,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE;YACnC,IAAI,OAAO,CAAC,KAAK,EAAE;gBACjB,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;gBAClE,IAAI,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,KAAK,GAAG,MAAM,EAAE;oBACvC,kCAAkC;oBAClC,IAAI,CAAC,GAAG,GAAG,OAAO,CAAC,GAAG,GAAG,MAAM,CAAC;iBACjC;qBAAM;oBACL,sCAAsC;oBACtC,MAAM,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,KAAK,GAAG,MAAM,EAAE,GAAG,EAAE,OAAO,CAAC,GAAG,GAAG,MAAM,EAAC,CAAC,CAAC;iBACjE;aACF;YACD,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;SACrB;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF","sourcesContent":["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Bindings from '../../models/bindings/bindings.js';\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nexport const enum CoverageType {\n  CSS = (1 << 0),\n  JavaScript = (1 << 1),\n  JavaScriptPerFunction = (1 << 2),\n}\n\nexport const enum SuspensionState {\n  Active = 'Active',\n  Suspending = 'Suspending',\n  Suspended = 'Suspended',\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  CoverageUpdated = 'CoverageUpdated',\n  CoverageReset = 'CoverageReset',\n}\n\nexport type EventTypes = {\n  [Events.CoverageUpdated]: CoverageInfo[],\n  [Events.CoverageReset]: void,\n};\n\nconst COVERAGE_POLLING_PERIOD_MS: number = 200;\n\ninterface BacklogItem<T> {\n  rawCoverageData: Array<T>;\n  stamp: number;\n}\n\nexport class CoverageModel extends SDK.SDKModel.SDKModel<EventTypes> {\n  private cpuProfilerModel: SDK.CPUProfilerModel.CPUProfilerModel|null;\n  private cssModel: SDK.CSSModel.CSSModel|null;\n  private debuggerModel: SDK.DebuggerModel.DebuggerModel|null;\n  private coverageByURL: Map<Platform.DevToolsPath.UrlString, URLCoverageInfo>;\n  private coverageByContentProvider: Map<TextUtils.ContentProvider.ContentProvider, CoverageInfo>;\n  private coverageUpdateTimes: Set<number>;\n  private suspensionState: SuspensionState;\n  private pollTimer: number|null;\n  private currentPollPromise: Promise<void>|null;\n  private shouldResumePollingOnResume: boolean|null;\n  private jsBacklog: BacklogItem<Protocol.Profiler.ScriptCoverage>[];\n  private cssBacklog: BacklogItem<Protocol.CSS.RuleUsage>[];\n  private performanceTraceRecording: boolean|null;\n\n  constructor(target: SDK.Target.Target) {\n    super(target);\n    this.cpuProfilerModel = target.model(SDK.CPUProfilerModel.CPUProfilerModel);\n    this.cssModel = target.model(SDK.CSSModel.CSSModel);\n    this.debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n\n    this.coverageByURL = new Map();\n    this.coverageByContentProvider = new Map();\n\n    // We keep track of the update times, because the other data-structures don't change if an\n    // update doesn't change the coverage. Some visualizations want to convey to the user that\n    // an update was received at a certain time, but did not result in a coverage change.\n    this.coverageUpdateTimes = new Set();\n\n    this.suspensionState = SuspensionState.Active;\n    this.pollTimer = null;\n    this.currentPollPromise = null;\n    this.shouldResumePollingOnResume = false;\n    this.jsBacklog = [];\n    this.cssBacklog = [];\n    this.performanceTraceRecording = false;\n  }\n\n  async start(jsCoveragePerBlock: boolean): Promise<boolean> {\n    if (this.suspensionState !== SuspensionState.Active) {\n      throw Error('Cannot start CoverageModel while it is not active.');\n    }\n    const promises = [];\n    if (this.cssModel) {\n      // Note there's no JS coverage since JS won't ever return\n      // coverage twice, even after it's restarted.\n      this.clearCSS();\n\n      this.cssModel.addEventListener(SDK.CSSModel.Events.StyleSheetAdded, this.handleStyleSheetAdded, this);\n      promises.push(this.cssModel.startCoverage());\n    }\n    if (this.cpuProfilerModel) {\n      promises.push(\n          this.cpuProfilerModel.startPreciseCoverage(jsCoveragePerBlock, this.preciseCoverageDeltaUpdate.bind(this)));\n    }\n\n    await Promise.all(promises);\n    return Boolean(this.cssModel || this.cpuProfilerModel);\n  }\n\n  preciseCoverageDeltaUpdate(timestamp: number, occasion: string, coverageData: Protocol.Profiler.ScriptCoverage[]):\n      void {\n    this.coverageUpdateTimes.add(timestamp);\n    void this.backlogOrProcessJSCoverage(coverageData, timestamp);\n  }\n\n  async stop(): Promise<void> {\n    await this.stopPolling();\n    const promises = [];\n    if (this.cpuProfilerModel) {\n      promises.push(this.cpuProfilerModel.stopPreciseCoverage());\n    }\n    if (this.cssModel) {\n      promises.push(this.cssModel.stopCoverage());\n      this.cssModel.removeEventListener(SDK.CSSModel.Events.StyleSheetAdded, this.handleStyleSheetAdded, this);\n    }\n    await Promise.all(promises);\n  }\n\n  reset(): void {\n    this.coverageByURL = new Map();\n    this.coverageByContentProvider = new Map();\n    this.coverageUpdateTimes = new Set();\n    this.dispatchEventToListeners(Events.CoverageReset);\n  }\n\n  async startPolling(): Promise<void> {\n    if (this.currentPollPromise || this.suspensionState !== SuspensionState.Active) {\n      return;\n    }\n    await this.pollLoop();\n  }\n\n  private async pollLoop(): Promise<void> {\n    this.clearTimer();\n    this.currentPollPromise = this.pollAndCallback();\n    await this.currentPollPromise;\n    if (this.suspensionState === SuspensionState.Active || this.performanceTraceRecording) {\n      this.pollTimer = window.setTimeout(() => this.pollLoop(), COVERAGE_POLLING_PERIOD_MS);\n    }\n  }\n\n  async stopPolling(): Promise<void> {\n    this.clearTimer();\n    await this.currentPollPromise;\n    this.currentPollPromise = null;\n    // Do one last poll to get the final data.\n    await this.pollAndCallback();\n  }\n\n  private async pollAndCallback(): Promise<void> {\n    if (this.suspensionState === SuspensionState.Suspended && !this.performanceTraceRecording) {\n      return;\n    }\n    const updates = await this.takeAllCoverage();\n    // This conditional should never trigger, as all intended ways to stop\n    // polling are awaiting the `_currentPollPromise` before suspending.\n    console.assert(\n        this.suspensionState !== SuspensionState.Suspended || Boolean(this.performanceTraceRecording),\n        'CoverageModel was suspended while polling.');\n    if (updates.length) {\n      this.dispatchEventToListeners(Events.CoverageUpdated, updates);\n    }\n  }\n\n  private clearTimer(): void {\n    if (this.pollTimer) {\n      clearTimeout(this.pollTimer);\n      this.pollTimer = null;\n    }\n  }\n\n  /**\n   * Stops polling as preparation for suspension. This function is idempotent\n   * due because it changes the state to suspending.\n   */\n  override async preSuspendModel(reason?: string): Promise<void> {\n    if (this.suspensionState !== SuspensionState.Active) {\n      return;\n    }\n    this.suspensionState = SuspensionState.Suspending;\n    if (reason === 'performance-timeline') {\n      this.performanceTraceRecording = true;\n      // Keep polling to the backlog if a performance trace is recorded.\n      return;\n    }\n    if (this.currentPollPromise) {\n      await this.stopPolling();\n      this.shouldResumePollingOnResume = true;\n    }\n  }\n\n  override async suspendModel(_reason?: string): Promise<void> {\n    this.suspensionState = SuspensionState.Suspended;\n  }\n\n  override async resumeModel(): Promise<void> {\n  }\n\n  /**\n   * Restarts polling after suspension. Note that the function is idempotent\n   * because starting polling is idempotent.\n   */\n  override async postResumeModel(): Promise<void> {\n    this.suspensionState = SuspensionState.Active;\n    this.performanceTraceRecording = false;\n    if (this.shouldResumePollingOnResume) {\n      this.shouldResumePollingOnResume = false;\n      await this.startPolling();\n    }\n  }\n\n  entries(): URLCoverageInfo[] {\n    return Array.from(this.coverageByURL.values());\n  }\n\n  getCoverageForUrl(url: Platform.DevToolsPath.UrlString): URLCoverageInfo|null {\n    return this.coverageByURL.get(url) || null;\n  }\n\n  usageForRange(contentProvider: TextUtils.ContentProvider.ContentProvider, startOffset: number, endOffset: number):\n      boolean|undefined {\n    const coverageInfo = this.coverageByContentProvider.get(contentProvider);\n    return coverageInfo && coverageInfo.usageForRange(startOffset, endOffset);\n  }\n\n  private clearCSS(): void {\n    for (const entry of this.coverageByContentProvider.values()) {\n      if (entry.type() !== CoverageType.CSS) {\n        continue;\n      }\n      const contentProvider = entry.getContentProvider() as SDK.CSSStyleSheetHeader.CSSStyleSheetHeader;\n      this.coverageByContentProvider.delete(contentProvider);\n      const urlEntry = this.coverageByURL.get(entry.url());\n      if (!urlEntry) {\n        continue;\n      }\n      const key = `${contentProvider.startLine}:${contentProvider.startColumn}`;\n      urlEntry.removeCoverageEntry(key, entry);\n      if (urlEntry.numberOfEntries() === 0) {\n        this.coverageByURL.delete(entry.url());\n      }\n    }\n\n    if (this.cssModel) {\n      for (const styleSheetHeader of this.cssModel.getAllStyleSheetHeaders()) {\n        this.addStyleSheetToCSSCoverage(styleSheetHeader);\n      }\n    }\n  }\n\n  private async takeAllCoverage(): Promise<CoverageInfo[]> {\n    const [updatesCSS, updatesJS] = await Promise.all([this.takeCSSCoverage(), this.takeJSCoverage()]);\n    return [...updatesCSS, ...updatesJS];\n  }\n\n  private async takeJSCoverage(): Promise<CoverageInfo[]> {\n    if (!this.cpuProfilerModel) {\n      return [];\n    }\n    const {coverage, timestamp} = await this.cpuProfilerModel.takePreciseCoverage();\n    this.coverageUpdateTimes.add(timestamp);\n    return this.backlogOrProcessJSCoverage(coverage, timestamp);\n  }\n\n  getCoverageUpdateTimes(): Set<number> {\n    return this.coverageUpdateTimes;\n  }\n\n  private async backlogOrProcessJSCoverage(\n      freshRawCoverageData: Protocol.Profiler.ScriptCoverage[], freshTimestamp: number): Promise<CoverageInfo[]> {\n    if (freshRawCoverageData.length > 0) {\n      this.jsBacklog.push({rawCoverageData: freshRawCoverageData, stamp: freshTimestamp});\n    }\n    if (this.suspensionState !== SuspensionState.Active) {\n      return [];\n    }\n    const ascendingByTimestamp = (x: {stamp: number}, y: {stamp: number}): number => x.stamp - y.stamp;\n    const results = [];\n    for (const {rawCoverageData, stamp} of this.jsBacklog.sort(ascendingByTimestamp)) {\n      results.push(this.processJSCoverage(rawCoverageData, stamp));\n    }\n    this.jsBacklog = [];\n    return results.flat();\n  }\n\n  async processJSBacklog(): Promise<void> {\n    void this.backlogOrProcessJSCoverage([], 0);\n  }\n\n  private processJSCoverage(scriptsCoverage: Protocol.Profiler.ScriptCoverage[], stamp: number): CoverageInfo[] {\n    if (!this.debuggerModel) {\n      return [];\n    }\n    const updatedEntries = [];\n    for (const entry of scriptsCoverage) {\n      const script = this.debuggerModel.scriptForId(entry.scriptId);\n      if (!script) {\n        continue;\n      }\n\n      const ranges = [];\n      let type = CoverageType.JavaScript;\n      for (const func of entry.functions) {\n        // Do not coerce undefined to false, i.e. only consider blockLevel to be false\n        // if back-end explicitly provides blockLevel field, otherwise presume blockLevel\n        // coverage is not available. Also, ignore non-block level functions that weren't\n        // ever called.\n        if (func.isBlockCoverage === false && !(func.ranges.length === 1 && !func.ranges[0].count)) {\n          type |= CoverageType.JavaScriptPerFunction;\n        }\n        for (const range of func.ranges) {\n          ranges.push(range);\n        }\n      }\n      const subentry = this.addCoverage(\n          script, script.contentLength, script.lineOffset, script.columnOffset, ranges, type as CoverageType, stamp);\n      if (subentry) {\n        updatedEntries.push(subentry);\n      }\n    }\n    return updatedEntries;\n  }\n\n  private handleStyleSheetAdded(\n      event: Common.EventTarget.EventTargetEvent<SDK.CSSStyleSheetHeader.CSSStyleSheetHeader>): void {\n    this.addStyleSheetToCSSCoverage(event.data);\n  }\n\n  private async takeCSSCoverage(): Promise<CoverageInfo[]> {\n    // Don't poll if we have no model, or are suspended.\n    if (!this.cssModel || this.suspensionState !== SuspensionState.Active) {\n      return [];\n    }\n    const {coverage, timestamp} = await this.cssModel.takeCoverageDelta();\n    this.coverageUpdateTimes.add(timestamp);\n    return this.backlogOrProcessCSSCoverage(coverage, timestamp);\n  }\n\n  private async backlogOrProcessCSSCoverage(freshRawCoverageData: Protocol.CSS.RuleUsage[], freshTimestamp: number):\n      Promise<CoverageInfo[]> {\n    if (freshRawCoverageData.length > 0) {\n      this.cssBacklog.push({rawCoverageData: freshRawCoverageData, stamp: freshTimestamp});\n    }\n    if (this.suspensionState !== SuspensionState.Active) {\n      return [];\n    }\n    const ascendingByTimestamp = (x: {stamp: number}, y: {stamp: number}): number => x.stamp - y.stamp;\n    const results = [];\n    for (const {rawCoverageData, stamp} of this.cssBacklog.sort(ascendingByTimestamp)) {\n      results.push(this.processCSSCoverage(rawCoverageData, stamp));\n    }\n    this.cssBacklog = [];\n    return results.flat();\n  }\n\n  private processCSSCoverage(ruleUsageList: Protocol.CSS.RuleUsage[], stamp: number): CoverageInfo[] {\n    if (!this.cssModel) {\n      return [];\n    }\n    const updatedEntries = [];\n    const rulesByStyleSheet = new Map<SDK.CSSStyleSheetHeader.CSSStyleSheetHeader, RangeUseCount[]>();\n    for (const rule of ruleUsageList) {\n      const styleSheetHeader = this.cssModel.styleSheetHeaderForId(rule.styleSheetId);\n      if (!styleSheetHeader) {\n        continue;\n      }\n      let ranges = rulesByStyleSheet.get(styleSheetHeader);\n      if (!ranges) {\n        ranges = [];\n        rulesByStyleSheet.set(styleSheetHeader, ranges);\n      }\n      ranges.push({startOffset: rule.startOffset, endOffset: rule.endOffset, count: Number(rule.used)});\n    }\n    for (const entry of rulesByStyleSheet) {\n      const styleSheetHeader = entry[0] as SDK.CSSStyleSheetHeader.CSSStyleSheetHeader;\n      const ranges = entry[1] as RangeUseCount[];\n      const subentry = this.addCoverage(\n          styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn,\n          ranges, CoverageType.CSS, stamp);\n      if (subentry) {\n        updatedEntries.push(subentry);\n      }\n    }\n    return updatedEntries;\n  }\n\n  private static convertToDisjointSegments(ranges: RangeUseCount[], stamp: number): CoverageSegment[] {\n    ranges.sort((a, b) => a.startOffset - b.startOffset);\n\n    const result: CoverageSegment[] = [];\n    const stack = [];\n    for (const entry of ranges) {\n      let top: RangeUseCount = stack[stack.length - 1];\n      while (top && top.endOffset <= entry.startOffset) {\n        append(top.endOffset, top.count);\n        stack.pop();\n        top = stack[stack.length - 1];\n      }\n      append(entry.startOffset, top ? top.count : 0);\n      stack.push(entry);\n    }\n\n    for (let top = stack.pop(); top; top = stack.pop()) {\n      append(top.endOffset, top.count);\n    }\n\n    function append(end: number, count: number): void {\n      const last = result[result.length - 1];\n      if (last) {\n        if (last.end === end) {\n          return;\n        }\n        if (last.count === count) {\n          last.end = end;\n          return;\n        }\n      }\n      result.push({end: end, count: count, stamp: stamp});\n    }\n\n    return result;\n  }\n\n  private addStyleSheetToCSSCoverage(styleSheetHeader: SDK.CSSStyleSheetHeader.CSSStyleSheetHeader): void {\n    this.addCoverage(\n        styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn, [],\n        CoverageType.CSS, Date.now());\n  }\n\n  private addCoverage(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, contentLength: number, startLine: number,\n      startColumn: number, ranges: RangeUseCount[], type: CoverageType, stamp: number): CoverageInfo|null {\n    const url = contentProvider.contentURL();\n    if (!url) {\n      return null;\n    }\n    let urlCoverage = this.coverageByURL.get(url);\n    let isNewUrlCoverage = false;\n    if (!urlCoverage) {\n      isNewUrlCoverage = true;\n      urlCoverage = new URLCoverageInfo(url);\n      this.coverageByURL.set(url, urlCoverage);\n    }\n\n    const coverageInfo = urlCoverage.ensureEntry(contentProvider, contentLength, startLine, startColumn, type);\n    this.coverageByContentProvider.set(contentProvider, coverageInfo);\n    const segments = CoverageModel.convertToDisjointSegments(ranges, stamp);\n    const last = segments[segments.length - 1];\n    if (last && last.end < contentLength) {\n      segments.push({end: contentLength, stamp: stamp, count: 0});\n    }\n    const usedSizeDelta = coverageInfo.mergeCoverage(segments);\n    if (!isNewUrlCoverage && usedSizeDelta === 0) {\n      return null;\n    }\n    urlCoverage.addToSizes(usedSizeDelta, 0);\n    return coverageInfo;\n  }\n\n  async exportReport(fos: Bindings.FileUtils.FileOutputStream): Promise<void> {\n    const result: {url: string, ranges: {start: number, end: number}[], text: string|null}[] = [];\n    const coverageByUrlKeys = Array.from(this.coverageByURL.keys()).sort();\n    for (const urlInfoKey of coverageByUrlKeys) {\n      const urlInfo = this.coverageByURL.get(urlInfoKey);\n      if (!urlInfo) {\n        continue;\n      }\n      const url = urlInfo.url();\n      if (url.startsWith('extensions::') || url.startsWith('chrome-extension://')) {\n        continue;\n      }\n      result.push(...await urlInfo.entriesForExport());\n    }\n    await fos.write(JSON.stringify(result, undefined, 2));\n    void fos.close();\n  }\n}\n\nSDK.SDKModel.SDKModel.register(CoverageModel, {capabilities: SDK.Target.Capability.None, autostart: false});\n\nexport interface EntryForExport {\n  url: Platform.DevToolsPath.UrlString;\n  ranges: {start: number, end: number}[];\n  text: string|null;\n}\n\nfunction locationCompare(a: string, b: string): number {\n  const [aLine, aPos] = a.split(':');\n  const [bLine, bPos] = b.split(':');\n  return Number.parseInt(aLine, 10) - Number.parseInt(bLine, 10) ||\n      Number.parseInt(aPos, 10) - Number.parseInt(bPos, 10);\n}\n\nexport class URLCoverageInfo extends Common.ObjectWrapper.ObjectWrapper<URLCoverageInfo.EventTypes> {\n  private readonly urlInternal: Platform.DevToolsPath.UrlString;\n  private coverageInfoByLocation: Map<string, CoverageInfo>;\n  private sizeInternal: number;\n  private usedSizeInternal: number;\n  private typeInternal!: CoverageType;\n  private isContentScriptInternal: boolean;\n\n  constructor(url: Platform.DevToolsPath.UrlString) {\n    super();\n\n    this.urlInternal = url;\n    this.coverageInfoByLocation = new Map();\n    this.sizeInternal = 0;\n    this.usedSizeInternal = 0;\n    this.isContentScriptInternal = false;\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.urlInternal;\n  }\n\n  type(): CoverageType {\n    return this.typeInternal;\n  }\n\n  size(): number {\n    return this.sizeInternal;\n  }\n\n  usedSize(): number {\n    return this.usedSizeInternal;\n  }\n\n  unusedSize(): number {\n    return this.sizeInternal - this.usedSizeInternal;\n  }\n\n  usedPercentage(): number {\n    // Per convention, empty files are reported as 100 % uncovered\n    if (this.sizeInternal === 0) {\n      return 0;\n    }\n    return this.usedSize() / this.size();\n  }\n\n  unusedPercentage(): number {\n    // Per convention, empty files are reported as 100 % uncovered\n    if (this.sizeInternal === 0) {\n      return 100;\n    }\n    return this.unusedSize() / this.size();\n  }\n\n  isContentScript(): boolean {\n    return this.isContentScriptInternal;\n  }\n\n  entries(): IterableIterator<CoverageInfo> {\n    return this.coverageInfoByLocation.values();\n  }\n\n  numberOfEntries(): number {\n    return this.coverageInfoByLocation.size;\n  }\n\n  removeCoverageEntry(key: string, entry: CoverageInfo): void {\n    if (!this.coverageInfoByLocation.delete(key)) {\n      return;\n    }\n    this.addToSizes(-entry.getUsedSize(), -entry.getSize());\n  }\n\n  addToSizes(usedSize: number, size: number): void {\n    this.usedSizeInternal += usedSize;\n    this.sizeInternal += size;\n\n    if (usedSize !== 0 || size !== 0) {\n      this.dispatchEventToListeners(URLCoverageInfo.Events.SizesChanged);\n    }\n  }\n\n  ensureEntry(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, contentLength: number, lineOffset: number,\n      columnOffset: number, type: CoverageType): CoverageInfo {\n    const key = `${lineOffset}:${columnOffset}`;\n    let entry = this.coverageInfoByLocation.get(key);\n\n    if ((type & CoverageType.JavaScript) && !this.coverageInfoByLocation.size) {\n      this.isContentScriptInternal = (contentProvider as SDK.Script.Script).isContentScript();\n    }\n    this.typeInternal |= type;\n\n    if (entry) {\n      entry.addCoverageType(type);\n      return entry;\n    }\n\n    if ((type & CoverageType.JavaScript) && !this.coverageInfoByLocation.size) {\n      this.isContentScriptInternal = (contentProvider as SDK.Script.Script).isContentScript();\n    }\n\n    entry = new CoverageInfo(contentProvider, contentLength, lineOffset, columnOffset, type);\n    this.coverageInfoByLocation.set(key, entry);\n    this.addToSizes(0, contentLength);\n\n    return entry;\n  }\n\n  async getFullText(): Promise<TextUtils.Text.Text|null> {\n    // For .html resources, multiple scripts share URL, but have different offsets.\n    let useFullText = false;\n    const url = this.url();\n    for (const info of this.coverageInfoByLocation.values()) {\n      const {lineOffset, columnOffset} = info.getOffsets();\n      if (lineOffset || columnOffset) {\n        useFullText = Boolean(url);\n        break;\n      }\n    }\n\n    if (!useFullText) {\n      return null;\n    }\n    const resource = SDK.ResourceTreeModel.ResourceTreeModel.resourceForURL(url);\n    if (!resource) {\n      return null;\n    }\n    const content = (await resource.requestContent()).content;\n    return new TextUtils.Text.Text(content || '');\n  }\n\n  entriesForExportBasedOnFullText(fullText: TextUtils.Text.Text): EntryForExport {\n    const coverageByLocationKeys = Array.from(this.coverageInfoByLocation.keys()).sort(locationCompare);\n    const entry: EntryForExport = {url: this.url(), ranges: [], text: fullText.value()};\n    for (const infoKey of coverageByLocationKeys) {\n      const info = this.coverageInfoByLocation.get(infoKey);\n      if (!info) {\n        continue;\n      }\n      const {lineOffset, columnOffset} = info.getOffsets();\n      const offset = fullText ? fullText.offsetFromPosition(lineOffset, columnOffset) : 0;\n      entry.ranges.push(...info.rangesForExport(offset));\n    }\n    return entry;\n  }\n\n  async entriesForExportBasedOnContent(): Promise<EntryForExport[]> {\n    const coverageByLocationKeys = Array.from(this.coverageInfoByLocation.keys()).sort(locationCompare);\n    const result = [];\n    for (const infoKey of coverageByLocationKeys) {\n      const info = this.coverageInfoByLocation.get(infoKey);\n      if (!info) {\n        continue;\n      }\n      const entry: EntryForExport = {\n        url: this.url(),\n        ranges: info.rangesForExport(),\n        text: (await info.getContentProvider().requestContent()).content,\n      };\n      result.push(entry);\n    }\n    return result;\n  }\n\n  async entriesForExport(): Promise<EntryForExport[]> {\n    const fullText = await this.getFullText();\n\n    // We have full text for this resource, resolve the offsets using the text line endings.\n    if (fullText) {\n      return [await this.entriesForExportBasedOnFullText(fullText)];\n    }\n\n    // Fall back to the per-script operation.\n    return this.entriesForExportBasedOnContent();\n  }\n}\n\nexport namespace URLCoverageInfo {\n  // TODO(crbug.com/1167717): Make this a const enum again\n  // eslint-disable-next-line rulesdir/const_enum\n  export enum Events {\n    SizesChanged = 'SizesChanged',\n  }\n\n  export type EventTypes = {\n    [Events.SizesChanged]: void,\n  };\n}\n\nexport const mergeSegments = (segmentsA: CoverageSegment[], segmentsB: CoverageSegment[]): CoverageSegment[] => {\n  const result: CoverageSegment[] = [];\n\n  let indexA = 0;\n  let indexB = 0;\n  while (indexA < segmentsA.length && indexB < segmentsB.length) {\n    const a = segmentsA[indexA];\n    const b = segmentsB[indexB];\n    const count = (a.count || 0) + (b.count || 0);\n    const end = Math.min(a.end, b.end);\n    const last = result[result.length - 1];\n    const stamp = Math.min(a.stamp, b.stamp);\n    if (!last || last.count !== count || last.stamp !== stamp) {\n      result.push({end: end, count: count, stamp: stamp});\n    } else {\n      last.end = end;\n    }\n    if (a.end <= b.end) {\n      indexA++;\n    }\n    if (a.end >= b.end) {\n      indexB++;\n    }\n  }\n\n  for (; indexA < segmentsA.length; indexA++) {\n    result.push(segmentsA[indexA]);\n  }\n  for (; indexB < segmentsB.length; indexB++) {\n    result.push(segmentsB[indexB]);\n  }\n  return result;\n};\n\nexport class CoverageInfo {\n  private contentProvider: TextUtils.ContentProvider.ContentProvider;\n  private size: number;\n  private usedSize: number;\n  private statsByTimestamp: Map<number, number>;\n  private lineOffset: number;\n  private columnOffset: number;\n  private coverageType: CoverageType;\n  private segments: CoverageSegment[];\n\n  constructor(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, size: number, lineOffset: number,\n      columnOffset: number, type: CoverageType) {\n    this.contentProvider = contentProvider;\n    this.size = size;\n    this.usedSize = 0;\n    this.statsByTimestamp = new Map();\n    this.lineOffset = lineOffset;\n    this.columnOffset = columnOffset;\n    this.coverageType = type;\n\n    this.segments = [];\n  }\n\n  getContentProvider(): TextUtils.ContentProvider.ContentProvider {\n    return this.contentProvider;\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.contentProvider.contentURL();\n  }\n\n  type(): CoverageType {\n    return this.coverageType;\n  }\n\n  addCoverageType(type: CoverageType): void {\n    this.coverageType |= type;\n  }\n\n  getOffsets(): {lineOffset: number, columnOffset: number} {\n    return {lineOffset: this.lineOffset, columnOffset: this.columnOffset};\n  }\n\n  /**\n   * Returns the delta by which usedSize increased.\n   */\n  mergeCoverage(segments: CoverageSegment[]): number {\n    const oldUsedSize = this.usedSize;\n    this.segments = mergeSegments(this.segments, segments);\n    this.updateStats();\n    return this.usedSize - oldUsedSize;\n  }\n\n  usedByTimestamp(): Map<number, number> {\n    return this.statsByTimestamp;\n  }\n\n  getSize(): number {\n    return this.size;\n  }\n\n  getUsedSize(): number {\n    return this.usedSize;\n  }\n\n  usageForRange(start: number, end: number): boolean {\n    let index = Platform.ArrayUtilities.upperBound(this.segments, start, (position, segment) => position - segment.end);\n    for (; index < this.segments.length && this.segments[index].end < end; ++index) {\n      if (this.segments[index].count) {\n        return true;\n      }\n    }\n    return index < this.segments.length && Boolean(this.segments[index].count);\n  }\n\n  private updateStats(): void {\n    this.statsByTimestamp = new Map();\n    this.usedSize = 0;\n\n    let last = 0;\n    for (const segment of this.segments) {\n      let previousCount = this.statsByTimestamp.get(segment.stamp);\n      if (previousCount === undefined) {\n        previousCount = 0;\n      }\n\n      if (segment.count) {\n        const used = segment.end - last;\n        this.usedSize += used;\n        this.statsByTimestamp.set(segment.stamp, previousCount + used);\n      }\n      last = segment.end;\n    }\n  }\n\n  rangesForExport(offset: number = 0): {start: number, end: number}[] {\n    const ranges = [];\n    let start = 0;\n    for (const segment of this.segments) {\n      if (segment.count) {\n        const last = ranges.length > 0 ? ranges[ranges.length - 1] : null;\n        if (last && last.end === start + offset) {\n          // We can extend the last segment.\n          last.end = segment.end + offset;\n        } else {\n          // There was a gap, add a new segment.\n          ranges.push({start: start + offset, end: segment.end + offset});\n        }\n      }\n      start = segment.end;\n    }\n    return ranges;\n  }\n}\nexport interface RangeUseCount {\n  startOffset: number;\n  endOffset: number;\n  count: number;\n}\nexport interface CoverageSegment {\n  end: number;\n  count: number;\n  stamp: number;\n}\n"]}