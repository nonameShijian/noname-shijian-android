{"version":3,"file":"NetworkRequestsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/NetworkRequestsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport {type TraceEventHandlerName, HandlerState} from './types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\n\nimport * as Types from '../types/types.js';\n\nconst MILLISECONDS_TO_MICROSECONDS = 1000;\nconst SECONDS_TO_MICROSECONDS = 1000000;\n\n// Network requests from traces are actually formed of 5 trace records.\n// This handler tracks all trace records based on the request ID, and\n// then creates a new synthetic trace event for those network requests.\n//\n// This interface, then, defines the shape of the object we intend to\n// keep for each request in the trace. In the finalize we will convert\n// these 5 types of trace records to a synthetic complete event that\n// represents a composite of these trace records.\ninterface TraceEventsForNetworkRequest {\n  willSendRequests?: Types.TraceEvents.TraceEventResourceWillSendRequest[];\n  sendRequests?: Types.TraceEvents.TraceEventResourceSendRequest[];\n  receiveResponse?: Types.TraceEvents.TraceEventResourceReceiveResponse;\n  resourceFinish?: Types.TraceEvents.TraceEventResourceFinish;\n  receivedData?: Types.TraceEvents.TraceEventResourceReceivedData[];\n}\n\ninterface NetworkRequestData {\n  byOrigin: Map<string, {\n    renderBlocking: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n    nonRenderBlocking: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n    all: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n  }>;\n  byTime: Types.TraceEvents.TraceEventSyntheticNetworkRequest[];\n}\n\nconst requestMap = new Map<string, TraceEventsForNetworkRequest>();\nconst requestsByOrigin = new Map<string, {\n  renderBlocking: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n  nonRenderBlocking: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n  all: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n}>();\nconst requestsByTime: Types.TraceEvents.TraceEventSyntheticNetworkRequest[] = [];\n\nfunction storeTraceEventWithRequestId<K extends keyof TraceEventsForNetworkRequest>(\n    requestId: string, key: K, value: TraceEventsForNetworkRequest[K]): void {\n  if (!requestMap.has(requestId)) {\n    requestMap.set(requestId, {});\n  }\n\n  const traceEvents = requestMap.get(requestId);\n  if (!traceEvents) {\n    throw new Error(`Unable to locate trace events for request ID ${requestId}`);\n  }\n\n  if (Array.isArray(traceEvents[key])) {\n    const target = traceEvents[key] as Types.TraceEvents.TraceEventData[];\n    const values = value as Types.TraceEvents.TraceEventData[];\n    target.push(...values);\n  } else {\n    traceEvents[key] = value;\n  }\n}\n\nfunction firstPositiveValueInList(entries: number[]): number {\n  for (const entry of entries) {\n    if (entry > 0) {\n      return entry;\n    }\n  }\n\n  // In the event we don't find a positive value, we return 0 so as to\n  // be a mathematical noop. It's typically not correct to return – say –\n  // a -1 here because it would affect the calculation of stats below.\n  return 0;\n}\n\nlet handlerState = HandlerState.UNINITIALIZED;\n\nexport function reset(): void {\n  requestsByOrigin.clear();\n  requestMap.clear();\n  requestsByTime.length = 0;\n\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Network Request handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceWillSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'willSendRequests', [event]);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'sendRequests', [event]);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceReceiveResponse(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receiveResponse', event);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceReceivedData(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receivedData', [event]);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceFinish(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceFinish', event);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Network Request handler is not initialized');\n  }\n\n  const {rendererProcessesByFrame} = metaHandlerData();\n  for (const [requestId, request] of requestMap.entries()) {\n    // If we have an incomplete set of events here, we choose to drop the network\n    // request rather than attempt to synthesize the missing data.\n    if (!request.sendRequests || !request.receiveResponse) {\n      continue;\n    }\n\n    // In the data we may get multiple willSendRequests and sendRequests, which\n    // will indicate that there are redirects for a given (sub)resource. In the\n    // case of a navigation, e.g., example.com/ we will get willSendRequests,\n    // and we should use these to calculate time spent in redirects.\n    // In the case of subresources, however, e.g., example.com/foo.js we will\n    // *only* get sendRequests, and we use these instead of willSendRequests\n    // to detect the time in redirects. We always use the sendRequest for the\n    // url, priority etc since it contains those values, but we use the\n    // willSendRequest (if it exists) to calculate the timestamp and durations\n    // of redirects.\n    const redirects: Types.TraceEvents.TraceEventSyntheticNetworkRedirect[] = [];\n    for (let i = 0; i < request.sendRequests.length - 1; i++) {\n      const sendRequest = request.sendRequests[i];\n      const nextSendRequest = request.sendRequests[i + 1];\n\n      // Use the willSendRequests as the source for redirects if possible.\n      // We default to those of the sendRequests, however, since willSendRequest\n      // is not guaranteed to be present in the data for every request.\n      let ts = sendRequest.ts;\n      let dur = Types.Timing.MicroSeconds(nextSendRequest.ts - sendRequest.ts);\n      if (request.willSendRequests && request.willSendRequests[i] && request.willSendRequests[i + 1]) {\n        const willSendRequest = request.willSendRequests[i];\n        const nextWillSendRequest = request.willSendRequests[i + 1];\n        ts = willSendRequest.ts;\n        dur = Types.Timing.MicroSeconds(nextWillSendRequest.ts - willSendRequest.ts);\n      }\n\n      redirects.push({\n        url: sendRequest.args.data.url,\n        priority: sendRequest.args.data.priority,\n        ts,\n        dur,\n      });\n    }\n\n    const firstSendRequest = request.sendRequests[0];\n    const finalSendRequest = request.sendRequests[request.sendRequests.length - 1];\n    const {timing} = request.receiveResponse.args.data;\n    // No timing indicates data URLs, which we ignore.\n    if (!timing) {\n      continue;\n    }\n\n    // Start time\n    // =======================\n    // The time where the request started, which is either the first willSendRequest\n    // event if there is one, or, if there is not, the sendRequest.\n    const startTime = (request.willSendRequests && request.willSendRequests.length) ?\n        Types.Timing.MicroSeconds(request.willSendRequests[0].ts) :\n        Types.Timing.MicroSeconds(firstSendRequest.ts);\n\n    // End redirect time\n    // =======================\n    // It's possible that when we start requesting data we will receive redirections.\n    // Here we note the time of the *last* willSendRequest / sendRequest event,\n    // which is used later on in the calculations for time queueing etc.\n    const endRedirectTime = (request.willSendRequests && request.willSendRequests.length) ?\n        Types.Timing.MicroSeconds(request.willSendRequests[request.willSendRequests.length - 1].ts) :\n        Types.Timing.MicroSeconds(finalSendRequest.ts);\n\n    // Finish time and end time\n    // =======================\n    // The finish time and the end time are subtly different.\n    //  - Finish time: records the point at which the network stack stopped receiving the data\n    //  - End time: the timestamp of the finish event itself (if one exists)\n    //\n    // The end time, then, will be slightly after the finish time.\n    const endTime = request.resourceFinish ? request.resourceFinish.ts : endRedirectTime;\n    const finishTime = request.resourceFinish ?\n        Types.Timing.MicroSeconds(request.resourceFinish.args.data.finishTime * SECONDS_TO_MICROSECONDS) :\n        Types.Timing.MicroSeconds(endTime);\n\n    // Network duration\n    // =======================\n    // Time spent on the network.\n    const networkDuration = Types.Timing.MicroSeconds((finishTime || endRedirectTime) - endRedirectTime);\n\n    // Processing duration\n    // =======================\n    // Time spent from start to end.\n    const processingDuration = Types.Timing.MicroSeconds(endTime - (finishTime || endTime));\n\n    // Redirection duration\n    // =======================\n    // Time between the first willSendRequest / sendRequest and last. This we place in *front* of the\n    // queueing, since the queueing time that we know about from the trace data is only the last request,\n    // i.e., the one that occurs after all the redirects.\n    const redirectionDuration = Types.Timing.MicroSeconds(endRedirectTime - startTime);\n\n    // Queueing\n    // =======================\n    // The amount of time queueing is the time between the request's start time to the requestTime\n    // arg recorded in the receiveResponse event. In the cases where the recorded start time is larger\n    // that the requestTime we set queueing time to zero.\n    const queueing = Types.Timing.MicroSeconds(Platform.NumberUtilities.clamp(\n        (timing.requestTime * SECONDS_TO_MICROSECONDS - endRedirectTime), 0, Number.MAX_VALUE));\n\n    // Stalled\n    // =======================\n    // The amount of time stalled is whichever positive number comes first from the\n    // following timing info: DNS start, Connection start, Send Start, or the time duration\n    // between our start time and receiving a response.\n    const stalled = Types.Timing.MicroSeconds(firstPositiveValueInList([\n      timing.dnsStart * MILLISECONDS_TO_MICROSECONDS,\n      timing.connectStart * MILLISECONDS_TO_MICROSECONDS,\n      timing.sendStart * MILLISECONDS_TO_MICROSECONDS,\n      (request.receiveResponse.ts - endRedirectTime),\n    ]));\n\n    // Waiting\n    // =======================\n    // Time from when the send finished going to when the headers were received.\n    const waiting =\n        Types.Timing.MicroSeconds((timing.receiveHeadersEnd - timing.sendEnd) * MILLISECONDS_TO_MICROSECONDS);\n\n    // Download\n    // =======================\n    // Time from receipt of headers to the finish time.\n    const downloadStart = Types.Timing.MicroSeconds(\n        timing.requestTime * SECONDS_TO_MICROSECONDS + timing.receiveHeadersEnd * MILLISECONDS_TO_MICROSECONDS);\n    const download = Types.Timing.MicroSeconds(((finishTime || downloadStart) - downloadStart));\n    const totalTime = Types.Timing.MicroSeconds(networkDuration + processingDuration);\n\n    // Collate a few values from the timing info.\n    const dnsLookup = Types.Timing.MicroSeconds((timing.dnsEnd - timing.dnsStart) * MILLISECONDS_TO_MICROSECONDS);\n    const ssl = Types.Timing.MicroSeconds((timing.sslEnd - timing.sslStart) * MILLISECONDS_TO_MICROSECONDS);\n    const proxyNegotiation =\n        Types.Timing.MicroSeconds((timing.proxyEnd - timing.proxyStart) * MILLISECONDS_TO_MICROSECONDS);\n    const requestSent = Types.Timing.MicroSeconds((timing.sendEnd - timing.sendStart) * MILLISECONDS_TO_MICROSECONDS);\n    const initialConnection =\n        Types.Timing.MicroSeconds((timing.connectEnd - timing.connectStart) * MILLISECONDS_TO_MICROSECONDS);\n\n    // Finally get some of the general data from the trace events.\n    const {priority, frame, url, renderBlocking} = finalSendRequest.args.data;\n    const {mimeType, fromCache, fromServiceWorker} = request.receiveResponse.args.data;\n    const {encodedDataLength, decodedBodyLength} =\n        request.resourceFinish ? request.resourceFinish.args.data : {encodedDataLength: 0, decodedBodyLength: 0};\n    const {receiveHeadersEnd, requestTime, sendEnd, sendStart, sslStart} = timing;\n    const {host, protocol, pathname, search} = new URL(url);\n    const isHttps = protocol === 'https:';\n    const renderProcesses = rendererProcessesByFrame.get(frame);\n    const processInfo = renderProcesses?.get(finalSendRequest.pid);\n    const requestingFrameUrl = processInfo ? processInfo.frame.url : '';\n\n    // Construct a synthetic trace event for this network request.\n    const networkEvent: Types.TraceEvents.TraceEventSyntheticNetworkRequest = {\n      args: {\n        data: {\n          decodedBodyLength,\n          dnsLookup,\n          download,\n          encodedDataLength,\n          finishTime,\n          frame,\n          fromCache,\n          fromServiceWorker,\n          initialConnection,\n          host,\n          isHttps,\n          mimeType,\n          networkDuration,\n          pathname,\n          search,\n          priority,\n          processingDuration,\n          protocol,\n          proxyNegotiation,\n          redirectionDuration,\n          queueing,\n          receiveHeadersEnd: Types.Timing.MicroSeconds(receiveHeadersEnd),\n          redirects,\n          requestId,\n          // In the event the property isn't set, assume non-blocking.\n          renderBlocking: renderBlocking ? renderBlocking : 'non_blocking',\n          requestSent,\n          requestTime,\n          requestingFrameUrl,\n          sendEnd: Types.Timing.MicroSeconds(sendEnd * MILLISECONDS_TO_MICROSECONDS),\n          sendStart: Types.Timing.MicroSeconds(sendStart * MILLISECONDS_TO_MICROSECONDS),\n          ssl,\n          sslStart: Types.Timing.MicroSeconds(sslStart * MILLISECONDS_TO_MICROSECONDS),\n          stalled,\n          statusCode: request.receiveResponse.args.data.statusCode,\n          stackTrace: finalSendRequest.args.data.stackTrace,\n          totalTime,\n          url,\n          waiting,\n        },\n      },\n      cat: 'loading',\n      name: 'SyntheticNetworkRequest',\n      ph: Types.TraceEvents.Phase.COMPLETE,\n      dur: Types.Timing.MicroSeconds(endTime - startTime),\n      tdur: Types.Timing.MicroSeconds(endTime - startTime),\n      ts: Types.Timing.MicroSeconds(startTime),\n      tts: Types.Timing.MicroSeconds(startTime),\n      pid: finalSendRequest.pid,\n      tid: finalSendRequest.tid,\n    };\n\n    // The timing data returned is from the original (uncached) request,\n    // which means that if we leave the above network record data as-is\n    // when the request came from either the disk cache or memory cache,\n    // our calculations will be incorrect.\n    //\n    // Here we override the request data args based on the timestamps of the\n    // various events in the case where the fromCache flag is set to true.\n    // These timestamps may not be perfect (indeed they don't always match\n    // the Network CDP domain exactly, which is likely an artifact of the way\n    // the data is routed on the backend), but they're the closest we have.\n    if (networkEvent.args.data.fromCache) {\n      // Zero out the network-based timing info.\n      networkEvent.args.data.queueing = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.waiting = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.dnsLookup = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.initialConnection = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.ssl = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.requestSent = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.proxyNegotiation = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.networkDuration = Types.Timing.MicroSeconds(0);\n\n      // Update the stalled and download values.\n      const endStalled = request.receiveResponse ? request.receiveResponse.ts : startTime;\n      networkEvent.args.data.stalled = Types.Timing.MicroSeconds(endStalled - startTime);\n      networkEvent.args.data.download = Types.Timing.MicroSeconds(endTime - endStalled);\n    }\n\n    const requests = Platform.MapUtilities.getWithDefault(requestsByOrigin, host, () => {\n      return {\n        renderBlocking: [],\n        nonRenderBlocking: [],\n        all: [],\n      };\n    });\n\n    // For ease of rendering we sometimes want to differentiate between\n    // render-blocking and non-render-blocking, so we divide the data here.\n    if (networkEvent.args.data.renderBlocking === 'non_blocking') {\n      requests.nonRenderBlocking.push(networkEvent);\n    } else {\n      requests.renderBlocking.push(networkEvent);\n    }\n\n    // However, there are also times where we just want to loop through all\n    // the captured requests, so here we store all of them together.\n    requests.all.push(networkEvent);\n    requestsByTime.push(networkEvent);\n  }\n\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport function data(): NetworkRequestData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Network Request handler is not finalized');\n  }\n\n  return {\n    byOrigin: new Map(requestsByOrigin),\n    byTime: [...requestsByTime],\n  };\n}\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Meta'];\n}\n"]}