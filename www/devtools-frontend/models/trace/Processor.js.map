{"version":3,"file":"Processor.js","sourceRoot":"","sources":["../../../../../../front_end/models/trace/Processor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as Types from './types/types.js';\nimport * as Handlers from './handlers/handlers.js';\n\nconst enum Status {\n  IDLE = 'IDLE',\n  PARSING = 'PARSING',\n  FINISHED_PARSING = 'FINISHED_PARSING',\n  ERRORED_WHILE_PARSING = 'ERRORED_WHILE_PARSING',\n}\n\nexport type TraceParseEventProgressData = {\n  index: number,\n  total: number,\n};\n\nexport class TraceParseProgressEvent extends Event {\n  static readonly eventName = 'traceparseprogress';\n  constructor(public data: TraceParseEventProgressData, init: EventInit = {bubbles: true}) {\n    super(TraceParseProgressEvent.eventName, init);\n  }\n}\ndeclare global {\n  interface HTMLElementEventMap {\n    [TraceParseProgressEvent.eventName]: TraceParseProgressEvent;\n  }\n}\n\nexport class TraceProcessor<EnabledModelHandlers extends {[key: string]: Handlers.Types.TraceEventHandler}> extends\n    EventTarget {\n  // We force the Meta handler to be enabled, so the TraceHandlers type here is\n  // the model handlers the user passes in and the Meta handler.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  readonly #traceHandlers: Handlers.Types.HandlersWithMeta<EnabledModelHandlers>;\n  #pauseDuration: number;\n  #eventsPerChunk: number;\n  #status = Status.IDLE;\n\n  static createWithAllHandlers(): TraceProcessor<typeof Handlers.ModelHandlers> {\n    return new TraceProcessor(Handlers.ModelHandlers);\n  }\n\n  constructor(traceHandlers: EnabledModelHandlers, {pauseDuration = 1, eventsPerChunk = 15_000} = {}) {\n    super();\n\n    this.#verifyHandlers(traceHandlers);\n    this.#traceHandlers = {\n      Meta: Handlers.ModelHandlers.Meta,\n      ...traceHandlers,\n    };\n    this.#pauseDuration = pauseDuration;\n    this.#eventsPerChunk = eventsPerChunk;\n  }\n\n  /**\n   * When the user passes in a set of handlers, we want to ensure that we have all\n   * the required handlers. Handlers can depend on other handlers, so if the user\n   * passes in FooHandler which depends on BarHandler, they must also pass in\n   * BarHandler too. This method verifies that all dependencies are met, and\n   * throws if not.\n   **/\n  #verifyHandlers(providedHandlers: EnabledModelHandlers): void {\n    // Tiny optimisation: if the amount of provided handlers matches the amount\n    // of handlers in the Handlers.ModelHandlers object, that means that the\n    // user has passed in every handler we have. So therefore they cannot have\n    // missed any, and there is no need to iterate through the handlers and\n    // check the dependencies.\n    if (Object.keys(providedHandlers).length === Object.keys(Handlers.ModelHandlers).length) {\n      return;\n    }\n    const requiredHandlerKeys: Set<Handlers.Types.TraceEventHandlerName> = new Set();\n    for (const [handlerName, handler] of Object.entries(providedHandlers)) {\n      requiredHandlerKeys.add(handlerName as Handlers.Types.TraceEventHandlerName);\n      for (const depName of (handler.deps?.() || [])) {\n        requiredHandlerKeys.add(depName);\n      }\n    }\n\n    const providedHandlerKeys = new Set(Object.keys(providedHandlers));\n    // We always force the Meta handler to be enabled when creating the\n    // Processor, so if it is missing from the set the user gave us that is OK,\n    // as we will have enabled it anyway.\n    requiredHandlerKeys.delete('Meta');\n\n    for (const requiredKey of requiredHandlerKeys) {\n      if (!providedHandlerKeys.has(requiredKey)) {\n        throw new Error(`Required handler ${requiredKey} not provided.`);\n      }\n    }\n  }\n\n  reset(): void {\n    if (this.#status === Status.PARSING) {\n      throw new Error('Trace processor can\\'t reset while parsing.');\n    }\n\n    const handlers = Object.values(this.#traceHandlers);\n    for (const handler of handlers) {\n      handler.reset();\n    }\n\n    this.#status = Status.IDLE;\n  }\n\n  async parse(traceEvents: readonly Types.TraceEvents.TraceEventData[], freshRecording = false): Promise<void> {\n    if (this.#status !== Status.IDLE) {\n      throw new Error(`Trace processor can't start parsing when not idle. Current state: ${this.#status}`);\n    }\n    try {\n      this.#status = Status.PARSING;\n      await this.#parse(traceEvents, freshRecording);\n      this.#status = Status.FINISHED_PARSING;\n    } catch (e) {\n      this.#status = Status.ERRORED_WHILE_PARSING;\n      throw e;\n    }\n  }\n\n  async #parse(traceEvents: readonly Types.TraceEvents.TraceEventData[], freshRecording: boolean): Promise<void> {\n    // This iterator steps through all events, periodically yielding back to the\n    // main thread to avoid blocking execution. It uses `dispatchEvent` to\n    // provide status update events, and other various bits of config like the\n    // pause duration and frequency.\n    const traceEventIterator = new TraceEventIterator(traceEvents, this.#pauseDuration, this.#eventsPerChunk);\n\n    // Convert to array so that we are able to iterate all handlers multiple times.\n    const sortedHandlers = [...sortHandlers(this.#traceHandlers).values()];\n    // Reset.\n    for (const handler of sortedHandlers) {\n      handler.reset();\n    }\n\n    // Initialize.\n    for (const handler of sortedHandlers) {\n      handler.initialize?.(freshRecording);\n    }\n\n    // Handle each event.\n    for await (const item of traceEventIterator) {\n      if (item.kind === IteratorItemType.STATUS_UPDATE) {\n        this.dispatchEvent(new TraceParseProgressEvent(item.data));\n        continue;\n      }\n      for (const handler of sortedHandlers) {\n        handler.handleEvent(item.data);\n      }\n    }\n\n    // Finalize.\n    for (const handler of sortedHandlers) {\n      await handler.finalize?.();\n    }\n  }\n\n  get data(): Handlers.Types.EnabledHandlerDataWithMeta<EnabledModelHandlers>|null {\n    if (this.#status !== Status.FINISHED_PARSING) {\n      return null;\n    }\n\n    const data = {};\n    for (const [name, handler] of Object.entries(this.#traceHandlers)) {\n      Object.assign(data, {[name]: handler.data()});\n    }\n\n    return data as Handlers.Types.EnabledHandlerDataWithMeta<EnabledModelHandlers>;\n  }\n}\n\n/**\n * Some Handlers need data provided by others. Dependencies of a handler handler are\n * declared in the `deps` field.\n * @returns A map from trace event handler name to trace event hander whose entries\n * iterate in such a way that each handler is visited after its dependencies.\n */\nexport function sortHandlers(\n    traceHandlers: Partial<{[key in Handlers.Types.TraceEventHandlerName]: Handlers.Types.TraceEventHandler}>):\n    Map<Handlers.Types.TraceEventHandlerName, Handlers.Types.TraceEventHandler> {\n  const sortedMap = new Map<Handlers.Types.TraceEventHandlerName, Handlers.Types.TraceEventHandler>();\n  const visited = new Set<Handlers.Types.TraceEventHandlerName>();\n  const visitHandler = (handlerName: Handlers.Types.TraceEventHandlerName): void => {\n    if (sortedMap.has(handlerName)) {\n      return;\n    }\n    if (visited.has(handlerName)) {\n      let stackPath = '';\n      for (const handler of visited) {\n        if (stackPath || handler === handlerName) {\n          stackPath += `${handler}->`;\n        }\n      }\n      stackPath += handlerName;\n      throw new Error(`Found dependency cycle in trace event handlers: ${stackPath}`);\n    }\n    visited.add(handlerName);\n    const handler = traceHandlers[handlerName];\n    if (!handler) {\n      return;\n    }\n    const deps = handler.deps?.();\n    if (deps) {\n      deps.forEach(visitHandler);\n    }\n    sortedMap.set(handlerName, handler);\n  };\n\n  for (const handlerName of Object.keys(traceHandlers)) {\n    visitHandler(handlerName as Handlers.Types.TraceEventHandlerName);\n  }\n  return sortedMap;\n}\n\nconst enum IteratorItemType {\n  TRACE_EVENT = 1,\n  STATUS_UPDATE = 2,\n}\n\ntype IteratorItem = IteratorTraceEventItem|IteratorStatusUpdateItem;\n\ntype IteratorTraceEventItem = {\n  kind: IteratorItemType.TRACE_EVENT,\n  data: Types.TraceEvents.TraceEventData,\n};\n\ntype IteratorStatusUpdateItem = {\n  kind: IteratorItemType.STATUS_UPDATE,\n  data: TraceParseEventProgressData,\n};\n\nclass TraceEventIterator {\n  #eventCount: number;\n\n  constructor(\n      private traceEvents: readonly Types.TraceEvents.TraceEventData[], private pauseDuration: number,\n      private eventsPerChunk: number) {\n    this.#eventCount = 0;\n  }\n\n  async * [Symbol.asyncIterator](): AsyncGenerator<IteratorItem, void, void> {\n    for (let i = 0, length = this.traceEvents.length; i < length; i++) {\n      // Every so often we take a break just to render.\n      if (++this.#eventCount % this.eventsPerChunk === 0) {\n        // Take the opportunity to provide status update events.\n        yield {kind: IteratorItemType.STATUS_UPDATE, data: {index: i, total: length}};\n        // Wait for rendering before resuming.\n        await new Promise(resolve => setTimeout(resolve, this.pauseDuration));\n      }\n\n      yield {kind: IteratorItemType.TRACE_EVENT, data: this.traceEvents[i]};\n    }\n  }\n}\n"]}