{"version":3,"file":"RendererHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/RendererHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\n\nimport {KnownEventName, KNOWN_EVENTS, type TraceEventHandlerName, HandlerState} from './types.js';\nimport * as Types from '../types/types.js';\n\nconst processes = new Map<Types.TraceEvents.ProcessID, RendererProcess>();\nconst traceEventToNode = new Map<RendererTraceEvent, RendererEventNode>();\nconst allRendererEvents: RendererTraceEvent[] = [];\nlet nodeIdCount = 0;\nconst makeRendererEventNodeId = (): RendererEventNodeId => (++nodeIdCount) as RendererEventNodeId;\n\nlet handlerState = HandlerState.UNINITIALIZED;\n\nconst makeRendererProcess = (): RendererProcess => ({\n  url: null,\n  isOnMainFrame: false,\n  threads: new Map(),\n});\n\nconst makeRendererThread = (): RendererThread => ({\n  name: null,\n  events: [],\n});\n\nconst makeEmptyRendererEventTree = (): RendererEventTree => ({\n  nodes: new Map(),\n  roots: new Set(),\n  maxDepth: 0,\n});\n\nconst makeEmptyRendererEventNode = (event: RendererTraceEvent, id: RendererEventNodeId): RendererEventNode => ({\n  event,\n  id,\n  parentId: null,\n  childrenIds: new Set(),\n  depth: 0,\n});\n\nconst getOrCreateRendererProcess =\n    (processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, pid: Types.TraceEvents.ProcessID):\n        RendererProcess => {\n          return Platform.MapUtilities.getWithDefault(processes, pid, makeRendererProcess);\n        };\n\nconst getOrCreateRendererThread = (process: RendererProcess, tid: Types.TraceEvents.ThreadID): RendererThread => {\n  return Platform.MapUtilities.getWithDefault(process.threads, tid, makeRendererThread);\n};\n\nexport function reset(): void {\n  processes.clear();\n  traceEventToNode.clear();\n  allRendererEvents.length = 0;\n  nodeIdCount = -1;\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('Renderer Handler was not reset');\n  }\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Renderer Handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isTraceEventInstant(event) || Types.TraceEvents.isTraceEventComplete(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.events.push(event);\n    allRendererEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Renderer Handler is not initialized');\n  }\n\n  const {mainFrameId, rendererProcessesByFrame, threadsInProcess} = metaHandlerData();\n  assignMeta(processes, mainFrameId, rendererProcessesByFrame, threadsInProcess);\n  sanitizeProcesses(processes);\n  buildHierarchy(processes, {filter: KNOWN_EVENTS});\n  sanitizeThreads(processes);\n\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport function data(): RendererHandlerData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Renderer Handler is not finalized');\n  }\n\n  return {\n    processes: new Map(processes),\n    traceEventToNode: new Map(traceEventToNode),\n    allRendererEvents: [...allRendererEvents],\n  };\n}\n\n/**\n * Steps through all the renderer processes we've located so far in the meta\n * handler, obtaining their URL, checking whether they are the main frame, and\n * collecting each one of their threads' name. This meta handler's data is\n * assigned to the renderer handler's data.\n */\nexport function assignMeta(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: Map<string, Map<Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame}>>,\n    threadsInProcess:\n        Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>):\n    void {\n  assignOrigin(processes, mainFrameId, rendererProcessesByFrame);\n  assignIsMainFrame(processes, mainFrameId, rendererProcessesByFrame);\n  assignThreadName(processes, rendererProcessesByFrame, threadsInProcess);\n}\n\n/**\n * Assigns origins to all threads in all processes.\n * @see assignMeta\n */\nexport function assignOrigin(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: Map<string, Map<Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame}>>):\n    void {\n  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid, processInfo] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      // Sometimes a single process is responsible with rendering multiple\n      // frames at the same time. For example, see https://crbug.com/1334563.\n      // When this happens, we'd still like to assign a single url per process\n      // so: 1) use the first frame rendered by this process as the url source\n      // and 2) if there's a more \"important\" frame found, us its url instead.\n      if (process.url === null /* first frame */ || frameId === mainFrameId /* more important frame */) {\n        // If we are here, it's because we care about this process and the URL. But before we store it, we check if it is a valid URL by trying to create a URL object. If it isn't, we won't set it, and this process will be filtered out later.\n        try {\n          new URL(processInfo.frame.url);\n          process.url = processInfo.frame.url;\n        } catch (e) {\n          process.url = null;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Assigns whether or not a thread is the main frame to all threads in all processes.\n * @see assignMeta\n */\nexport function assignIsMainFrame(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: Map<string, Map<Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame}>>):\n    void {\n  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      // We have this go in one direction; once a renderer has been flagged as\n      // being on the main frame, we don't unset it to false if were to show up\n      // in a subframe. Equally, if we already saw this renderer in a subframe,\n      // but it becomes the main frame, the flag would get updated.\n      if (frameId === mainFrameId) {\n        process.isOnMainFrame = true;\n      }\n    }\n  }\n}\n\n/**\n * Assigns the thread name to all threads in all processes.\n * @see assignMeta\n */\nexport function assignThreadName(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>,\n    rendererProcessesByFrame: Map<string, Map<Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame}>>,\n    threadsInProcess:\n        Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>):\n    void {\n  for (const [, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      for (const [tid, threadInfo] of threadsInProcess.get(pid) ?? []) {\n        const thread = getOrCreateRendererThread(process, tid);\n        thread.name = threadInfo?.args.name ?? `${tid}`;\n      }\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes processes with an unkonwn origin.\n */\nexport function sanitizeProcesses(processes: Map<Types.TraceEvents.ProcessID, RendererProcess>): void {\n  for (const [pid, process] of processes) {\n    // If the process had no url, or if it had a malformed url that could not be\n    // parsed for some reason, or if it's an \"about:\" origin, delete it.\n    // This is done because we don't really care about processes for which we\n    // can't provide actionable insights to the user (e.g. about:blank pages).\n    if (process.url === null) {\n      processes.delete(pid);\n      continue;\n    }\n    const asUrl = new URL(process.url);\n    if (asUrl.protocol === 'about:') {\n      processes.delete(pid);\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes threads with no roots.\n */\nexport function sanitizeThreads(processes: Map<Types.TraceEvents.ProcessID, RendererProcess>): void {\n  for (const [, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      // If the thread has no roots, also delete it. Otherwise, there's going to\n      // be space taken, even though nothing is rendered in the track manager.\n      if (!thread.tree?.roots.size) {\n        process.threads.delete(tid);\n      }\n    }\n  }\n}\n\n/**\n * Creates a hierarchical structure from the trace events. Each thread in each\n * process will contribute to their own individual hierarchy.\n *\n * The trace data comes in as a contiguous array of events, against which we\n * make a couple of assumptions:\n *\n *  1. Events are temporally-ordered in terms of start time (though they're\n *     not necessarily ordered as such in the data stream).\n *  2. If event B's start and end times are within event A's time boundaries\n *     we assume that A is the parent of B.\n *\n * Therefore we expect to reformulate something like:\n *\n * [ Task A ][ Task B ][ Task C ][ Task D ][ Task E ]\n *\n * Into something hierarchically-arranged like below:\n *\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n */\nexport function buildHierarchy(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>,\n    options: {filter: {has: (name: KnownEventName) => boolean}}): void {\n  for (const [, process] of processes) {\n    for (const [, thread] of process.threads) {\n      // Step 1. Massage the data.\n      Helpers.Trace.sortTraceEventsInPlace(thread.events);\n      // Step 2. Build the tree.\n      thread.tree = treify(thread.events, options);\n    }\n  }\n}\n\n/**\n * Builds a hierarchy of the trace events in a particular thread of a\n * particular process, assuming that they're sorted, by iterating through all of\n * the events in order.\n *\n * The approach is analogous to how a parser would be implemented. A stack\n * maintains local context. A scanner peeks and pops from the data stream.\n * Various \"tokens\" (events) are treated as \"whitespace\" (ignored).\n *\n * The tree starts out empty and is populated as the hierarchy is built. The\n * nodes are also assumed to be created empty, with no known parent or children.\n *\n * Complexity: O(n), where n = number of events\n */\nexport function treify(\n    events: RendererTraceEvent[], options: {filter: {has: (name: KnownEventName) => boolean}}): RendererEventTree {\n  const stack = [];\n  // Reset the node id counter for every new renderer.\n  nodeIdCount = -1;\n  const tree = makeEmptyRendererEventTree();\n  for (let i = 0; i < events.length; i++) {\n    const event = events[i];\n\n    // If the current event should not be part of the tree, then simply proceed\n    // with the next event.\n    if (!options.filter.has(event.name as KnownEventName)) {\n      continue;\n    }\n\n    const duration = event.dur || 0;\n    const nodeId = makeRendererEventNodeId();\n    const node = makeEmptyRendererEventNode(event, nodeId);\n\n    // If the parent stack is empty, then the current event is a root. Create a\n    // node for it, mark it as a root, then proceed with the next event.\n    if (stack.length === 0) {\n      tree.nodes.set(nodeId, node);\n      tree.roots.add(nodeId);\n      event.selfTime = Types.Timing.MicroSeconds(duration);\n      stack.push(node);\n      tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n      traceEventToNode.set(event, node);\n      continue;\n    }\n\n    const parentNode = stack.at(-1);\n    if (parentNode === undefined) {\n      throw new Error('Impossible: no parent node found in the stack');\n    }\n\n    const parentEvent = parentNode.event;\n\n    const begin = event.ts;\n    const parentBegin = parentEvent.ts;\n    const parentDuration = parentEvent.dur || 0;\n    const end = begin + duration;\n    const parentEnd = parentBegin + parentDuration;\n    // Check the relationship between the parent event at the top of the stack,\n    // and the current event being processed. There are only 4 distinct\n    // possiblities, only 2 of them actually valid, given the assumed sorting:\n    // 1. Current event starts before the parent event, ends whenever. (invalid)\n    // 2. Current event starts after the parent event, ends whenever. (valid)\n    // 3. Current event starts during the parent event, ends after. (invalid)\n    // 4. Current event starts and ends during the parent event. (valid)\n\n    // 1. If the current event starts before the parent event, then the data is\n    //    not sorted properly, messed up some way, or this logic is incomplete.\n    const startsBeforeParent = begin < parentBegin;\n    if (startsBeforeParent) {\n      throw new Error('Impossible: current event starts before the parent event');\n    }\n\n    // 2. If the current event starts after the parent event, then it's a new\n    //    parent. Pop, then handle current event again.\n    const startsAfterParent = begin >= parentEnd;\n    if (startsAfterParent) {\n      stack.pop();\n      i--;\n      // The last created node has been discarded, so discard this id.\n      nodeIdCount--;\n      continue;\n    }\n\n    // 3. If the current event starts during the parent event, but ends after\n    //    it, then the data is messed up some way.\n    const endsAfterParent = end > parentEnd;\n    if (endsAfterParent) {\n      throw new Error('Impossible: current event starts during the parent event');\n    }\n\n    // 4. The only remaining case is the common case, where the current event is\n    //    contained within the parent event. Create a node for the current\n    //    event, establish the parent/child relationship, then proceed with the\n    //    next event.\n    tree.nodes.set(nodeId, node);\n    node.depth = stack.length;\n    node.parentId = parentNode.id;\n    parentNode.childrenIds.add(nodeId);\n    event.selfTime = Types.Timing.MicroSeconds(duration);\n    if (parentEvent.selfTime !== undefined) {\n      parentEvent.selfTime = Types.Timing.MicroSeconds(parentEvent.selfTime - (event.dur || 0));\n    }\n    stack.push(node);\n    tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n    traceEventToNode.set(event, node);\n  }\n  return tree;\n}\n\nexport const FORCED_LAYOUT_EVENT_NAMES = new Set([\n  KnownEventName.Layout,\n]);\n\nexport const FORCED_RECALC_STYLE_EVENTS = new Set([\n  KnownEventName.RecalculateStyles,\n  KnownEventName.UpdateLayoutTree,\n]);\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Meta', 'Samples'];\n}\n\nexport interface RendererHandlerData {\n  processes: Map<Types.TraceEvents.ProcessID, RendererProcess>;\n  traceEventToNode: Map<RendererTraceEvent, RendererEventNode>;\n  allRendererEvents: RendererTraceEvent[];\n}\n\nexport interface RendererProcess {\n  // In an ideal world this would be modelled as a URL, but URLs cannot be sent\n  // between the main thread and workers, so we have to store it as a string.\n  url: string|null;\n  isOnMainFrame: boolean;\n  threads: Map<Types.TraceEvents.ThreadID, RendererThread>;\n}\n\nexport interface RendererThread {\n  name: string|null;\n  events: RendererTraceEvent[];\n  tree?: RendererEventTree;\n}\n\ninterface RendererEventData {\n  selfTime: Types.Timing.MicroSeconds;\n  initiator: RendererTraceEvent;\n  parent?: RendererTraceEvent;\n  hotFunctionsStackTraces: Types.TraceEvents.TraceEventCallFrame[][];\n}\n\nexport type RendererTraceEvent = Types.TraceEvents.TraceEventRendererData&Partial<RendererEventData>;\n\nexport interface RendererEventTree {\n  nodes: Map<RendererEventNodeId, RendererEventNode>;\n  roots: Set<RendererEventNodeId>;\n  maxDepth: number;\n}\n\nexport interface RendererEventNode {\n  event: RendererTraceEvent;\n  depth: number;\n  id: RendererEventNodeId;\n  parentId?: RendererEventNodeId|null;\n  childrenIds: Set<RendererEventNodeId>;\n}\n\nclass RendererEventNodeIdTag {\n  /* eslint-disable-next-line no-unused-private-class-members */\n  readonly #tag: (symbol|undefined);\n}\nexport type RendererEventNodeId = number&RendererEventNodeIdTag;\n"]}