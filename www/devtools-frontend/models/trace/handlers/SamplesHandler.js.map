{"version":3,"file":"SamplesHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/SamplesHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {HandlerState, EventCategory, KNOWN_EVENTS, type KnownEventName} from './types.js';\n\n/**\n * Sorts samples in place, in order, by their start time.\n */\nexport function sortProfileSamples(samples: ProfileSample[]): void {\n  samples.sort((a, b) => {\n    const aBeginTime = a.ts;\n    const bBeginTime = b.ts;\n    if (aBeginTime < bBeginTime) {\n      return -1;\n    }\n    if (aBeginTime > bBeginTime) {\n      return 1;\n    }\n    return 0;\n  });\n}\n\nconst KNOWN_BOUNDARIES = new Set([\n  EventCategory.Other,\n  EventCategory.V8,\n  EventCategory.Js,\n  EventCategory.Gc,\n]);\n\nconst ALLOWED_CALL_FRAME_CODE_TYPES = new Set([undefined, 'JS']);\nconst BANNED_CALL_FRAME_URL_REGS = [/^chrome-extension:\\/\\//, /^extensions::/];\n\nconst SAMPLING_INTERVAL = Types.Timing.MicroSeconds(200);\n\nconst events =\n    new Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventComplete[]>>();\nconst profiles = new Map<Types.TraceEvents.ProfileID, Partial<SamplesProfile>>();\nconst processes = new Map<Types.TraceEvents.ProcessID, SamplesProcess>();\n\nlet handlerState = HandlerState.UNINITIALIZED;\n\nconst makeSamplesProcess = (): SamplesProcess => ({\n  threads: new Map(),\n});\n\nconst makeSamplesThread = (profile: SamplesProfile): SamplesThread => ({\n  profile,\n});\n\nconst makeEmptyProfileTree = (): ProfileTree => ({\n  nodes: new Map(),\n});\n\nconst makeEmptyProfileNode = (callFrame: Types.TraceEvents.TraceEventCallFrame): ProfileNode => ({\n  callFrame,\n  parentId: null,\n  childrenIds: new Set(),\n});\n\nconst makeProfileSample =\n    (nodeId: Types.TraceEvents.CallFrameID, pid: Types.TraceEvents.ProcessID, tid: Types.TraceEvents.ThreadID,\n     ts: Types.Timing.MicroSeconds): ProfileSample => ({\n      topmostStackFrame: {nodeId},\n      tid,\n      pid,\n      ts,\n    });\n\nconst makeProfileCall = (nodeId: Types.TraceEvents.CallFrameID, sample: ProfileSample): ProfileCall => ({\n  stackFrame: {nodeId},\n  tid: sample.tid,\n  pid: sample.pid,\n  ts: sample.ts,\n  dur: Types.Timing.MicroSeconds(0),\n  selfDur: Types.Timing.MicroSeconds(0),\n  children: [],\n});\n\nconst makeEmptyProfileFunction = (nodeId: Types.TraceEvents.CallFrameID): ProfileFunction => ({\n  stackFrame: {nodeId},\n  calls: [],\n  durPercent: 0,\n  selfDurPercent: 0,\n});\n\nconst getOrCreateSamplesProcess =\n    (processes: Map<Types.TraceEvents.ProcessID, SamplesProcess>, pid: Types.TraceEvents.ProcessID): SamplesProcess => {\n      return Platform.MapUtilities.getWithDefault(processes, pid, makeSamplesProcess);\n    };\n\nconst getOrCreateSamplesThread =\n    (process: SamplesProcess, tid: Types.TraceEvents.ThreadID, profile: SamplesProfile): SamplesThread => {\n      return Platform.MapUtilities.getWithDefault(process.threads, tid, () => makeSamplesThread(profile));\n    };\n\nexport function reset(): void {\n  events.clear();\n  profiles.clear();\n  processes.clear();\n\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('Samples Handler was not reset');\n  }\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Samples Handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isTraceEventProfile(event)) {\n    const profile = Platform.MapUtilities.getWithDefault(profiles, event.id, (): Partial<SamplesProfile> => ({}));\n    profile.head = event;\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventProfileChunk(event)) {\n    const profile = Platform.MapUtilities.getWithDefault(profiles, event.id, (): Partial<SamplesProfile> => ({}));\n    profile.chunks = profile.chunks ?? [];\n    profile.chunks.push(event);\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventComplete(event)) {\n    const process = Platform.MapUtilities.getWithDefault(events, event.pid, () => new Map());\n    const thread = Platform.MapUtilities.getWithDefault(process, event.tid, () => []);\n    thread.push(event);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Samples Handler is not initialized');\n  }\n  buildProcessesAndThreads(profiles, processes);\n  buildHierarchy(processes, events);\n\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport function data(): SamplesHandlerData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Samples Handler is not finalized');\n  }\n\n  return {\n    profiles: new Map(profiles),\n    processes: new Map(processes),\n  };\n}\n\n/**\n * Builds processes and threads from the accumulated profile chunks. This is\n * done during finalize instead of during event handling because profile heads\n * and chunks are sometimes retrieved out of order, or are incomplete.\n */\nexport function buildProcessesAndThreads(\n    profiles: Map<Types.TraceEvents.ProfileID, Partial<SamplesProfile>>,\n    processes: Map<Types.TraceEvents.ProcessID, SamplesProcess>): void {\n  for (const [, profile] of profiles) {\n    // Sometimes the trace includes empty profiles, or orphaned chunks, even\n    // after going through all the trace events. Ignore.\n    const {head, chunks} = profile;\n    if (!head || !chunks?.length) {\n      continue;\n    }\n\n    // Note: events are collected on a different thread than what's sampled.\n    // The correct process and thread ids are specified by the profile.\n    const pid = head.pid;\n    const tid = head.tid;\n    getOrCreateSamplesThread(getOrCreateSamplesProcess(processes, pid), tid, profile as SamplesProfile);\n  }\n}\n\n/**\n * Converts the raw profile data into hierarchical and ordered structures from\n * the stack traces that were sampled during a recording. Each thread in each\n * process will contribute to their own individual profile.\n *\n * Our V8 profiler is a sampling profiler. This means that it probes the\n * program's call stack at regular intervals defined by the sampling frequency.\n * The raw profile data comes in as multiple events, from which a profile is\n * built.\n *\n * The generated data will be comprised of several parts:\n * 1. \"tree\": All the complete stack traces, represented by a tree whose roots\n *    are the bottomest stack frames of all stack traces.\n * 2. \"samples\": All the individual samples, as an ordered list where each item\n *    points to the topmost stack frame at a particular point in time.\n * 3. \"calls\": A list of profile calls, where each item represents multiple\n *    samples coalesced into a contiguous event. Each item will have a\n *    timestamp, duration, and refer to a stack frame and its child frames\n *    (all together forming multiple stack traces).\n */\nexport function buildHierarchy(\n    processes: Map<Types.TraceEvents.ProcessID, SamplesProcess>,\n    events: Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventComplete[]>>):\n    void {\n  for (const [pid, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      // Step 1. Massage the data.\n      Helpers.Trace.sortTraceEventsInPlace(thread.profile.chunks);\n      // ...and collect boundaries.\n      const boundariesOptions = {filter: KNOWN_BOUNDARIES};\n      const boundaries = thread.boundaries = collectBoundaries(events, pid, tid, boundariesOptions);\n\n      // Step 2. Collect all the complete stack traces into a tree. (Extract tree structure from profile)\n      const tree = thread.tree = collectStackTraces(thread.profile.chunks);\n\n      // Step 3. Collect all the individual samples into a list.\n      const {startTime} = thread.profile.head.args.data;\n      const samplesOptions = {filterCodeTypes: true, filterUrls: true};\n      const samples = thread.samples = collectSamples(pid, tid, startTime, tree, thread.profile.chunks, samplesOptions);\n\n      // Step 4. Coalesce samples. (Apply tree to samples, turn them into calls, and merge where appropriate).\n      const merge = mergeCalls(samples.map(sample => buildProfileCallFromSample(tree, sample)), boundaries);\n      thread.calls = merge.calls;\n      thread.dur = merge.dur;\n    }\n  }\n}\n\n/**\n * Builds an array of timestamps corresponding to the begin and end boundaries\n * of the events on the specified process and thread.\n *\n * Therefore we expect to reformulate a set of events which can be represented\n * hierarchically like:\n *\n * |=========== Task A ===============|== Task E ==|\n *   |=== Task B ===|== Task D ==|\n *     |= Task C =|\n *\n * ...into something ordered like below:\n *\n * | | |          | |                 |            |\n * |=========== Task A ===============|== Task E ==|\n * | |=== Task B ===|== Task D ==|    |            |\n * | | |= Task C =| |            |    |            |\n * | | |          | |            |    |            |\n * X X X          X X            X    X            X (boundaries)\n */\nexport function collectBoundaries(\n    events: Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventComplete[]>>,\n    pid: Types.TraceEvents.ProcessID, tid: Types.TraceEvents.ThreadID,\n    options: {filter: {has: (category: EventCategory) => boolean}}): Types.Timing.MicroSeconds[] {\n  const process = events.get(pid);\n  if (!process) {\n    return [];\n  }\n\n  const thread = process.get(tid);\n  if (!thread) {\n    return [];\n  }\n\n  const boundaries = new Set<Types.Timing.MicroSeconds>();\n\n  for (const event of thread) {\n    const category = KNOWN_EVENTS.get(event.name as KnownEventName)?.category ?? EventCategory.Other;\n    if (!options.filter.has(category)) {\n      continue;\n    }\n    boundaries.add(event.ts);\n    boundaries.add(Types.Timing.MicroSeconds(event.ts + event.dur));\n  }\n\n  return [...boundaries].sort((a, b) => a < b ? -1 : 1);\n}\n\n/**\n * Builds all the complete stack traces that exist in a particular thread of a\n * particular process. They will be stored as a tree. The roots of this tree are\n * the bottomest stack frames of all individual stack traces.\n *\n * The stack traces are retrieved in partial chains, each chain as part of a\n * trace event. This method collects the data into a single tree.\n *\n * Therefore we expect to reformulate something like:\n *\n * Chain 1: [A, B <- A, C <- B]\n * Chain 2: [D <- A, E <- D]\n * Chain 3: [G]\n * Chain 4: [F <- B]\n * Chain 5: [H <- G, I <- H]\n *\n * ...into something hierarchically-arranged like below:\n *\n *     A       G\n *    / \\      |\n *   B   D     H\n *  / \\   \\    |\n * C   F   E   I\n */\nexport function collectStackTraces(\n    chunks: Types.TraceEvents.TraceEventProfileChunk[],\n    options?: {filterCodeTypes: boolean, filterUrls: boolean}): ProfileTree {\n  const tree = makeEmptyProfileTree();\n\n  for (const chunk of chunks) {\n    const cpuProfile = chunk.args.data?.cpuProfile;\n    if (!cpuProfile) {\n      continue;\n    }\n    const chain = cpuProfile.nodes;\n    if (!chain) {\n      continue;\n    }\n\n    for (const link of chain) {\n      const nodeId = link.id;\n      const parentNodeId = link.parent;\n      const callFrame = link.callFrame;\n\n      // If the current call frame should not be part of the tree, then simply proceed\n      // with the next call frame.\n      if (!isAllowedCallFrame(callFrame, options)) {\n        continue;\n      }\n\n      const node = Platform.MapUtilities.getWithDefault(tree.nodes, nodeId, () => makeEmptyProfileNode(callFrame));\n\n      // If the call frame has no parent, then it's the bottomest stack frame of\n      // a stack trace (aka a root).\n      if (parentNodeId === undefined) {\n        continue;\n      }\n\n      // Otherwise, this call frame has a parent and threfore it's a stack frame\n      // part of a larger stack trace. Each stack frame can only have a single\n      // parent (called into by another unique stack frame), with multiple\n      // children (calling into multiple unique stack frames). If a codepoint is\n      // reached in multiple ways, multiple stack traces are created by V8.\n      node.parentId = parentNodeId;\n      tree.nodes.get(parentNodeId)?.childrenIds.add(nodeId);\n    }\n  }\n\n  return tree;\n}\n\n/**\n * Collects all the individual samples that exist in a particular thread of a\n * particular process. They will be stored as an ordered list. Each entry\n * represents a sampled stack trace by pointing to the topmost stack frame at\n * that particular time.\n *\n * The samples are retrieved in buckets, each bucket as part of a trace event,\n * and each sample at a positive or negative delta cumulatively relative to the\n * profile's start time. This method collects the data into a single list.\n *\n * Therefore we expect to reformulate something like:\n *\n * Event 1 at 0µs: [A at Δ+1µs, A at Δ+2µs, B at Δ-1µs, C at Δ+2µs]\n * Event 2 at 9µs: [A at Δ+1µs, D at Δ+9µs, E at Δ-1µs]\n *\n * ...where each sample in each event points to the tompost stack frame at that\n * particular point in time (e.g. the first sample's tompost stack frame is A),\n * into something ordered like below:\n *\n * [A at 1µs, B at 2µs, A at 3µs, C at 4µs, A at 10µs, E at 18µs, D at 19µs]\n *\n * ...where each sample has an absolute timestamp, and the list is ordered.\n */\nexport function collectSamples(\n    pid: Types.TraceEvents.ProcessID, tid: Types.TraceEvents.ThreadID, ts: Types.Timing.MicroSeconds, tree: ProfileTree,\n    chunks: Types.TraceEvents.TraceEventProfileChunk[],\n    options?: {filterCodeTypes: boolean, filterUrls: boolean}): ProfileSample[] {\n  const samples: ProfileSample[] = [];\n\n  for (const chunk of chunks) {\n    const {timeDeltas, cpuProfile} = chunk.args.data ?? {};\n    if (!timeDeltas || !cpuProfile) {\n      continue;\n    }\n\n    for (let i = 0; i < timeDeltas.length; i++) {\n      const timeDelta = timeDeltas[i];\n      const nodeId = cpuProfile.samples[i];\n      // The timestamp of each sample is at a positive or negative delta,\n      // cumulatively relative to the profile's start time.\n      ts = Types.Timing.MicroSeconds(ts + timeDelta);\n\n      // The call frame may not have been added to the stack traces tree (e.g.\n      // if its code type or url was banned). If there is no allowed stack frame\n      // as part of a stack trace, then this sample is dropped.\n      const topmostAllowedNodeId = findTopmostAllowedCallFrame(nodeId, tree, options);\n      if (topmostAllowedNodeId === null) {\n        continue;\n      }\n\n      // Otherwise, push the topmost allowed stack frame.\n      samples.push(makeProfileSample(topmostAllowedNodeId, pid, tid, ts));\n    }\n  }\n\n  sortProfileSamples(samples);\n  return samples;\n}\n\n/**\n * For a list of samples in a thread in a process, merges together stack frames\n * which have been sampled consecutively and which do not cross boundaries. The\n * samples and boundaries arrays are assumed to be sorted.\n *\n * Therefore, if the previously collected stack traces tree looks like this:\n *\n *   A   E\n *  / \\\n * B   D\n * |\n * C\n *\n * ...we expect to reformulate something like:\n *\n * [A, B, C, C .. C, B, A, A .. A, D, D .. D, A, A .. A, E, E .. E]\n *\n * ...where each sample points to the tompost stack frame at that particular\n * point in time (e.g. the first sample's tompost stack frame is A, the last\n * sample's topmost stack frame is E, etc.), and thus the expanded samples array\n * can be represented as:\n *\n * +------------> (sample at time)\n * |\n * |A|A|A|A|A|A|A|A|A|A|A|A|A|A|A|A|A| |E|E|E|E|E|E|\n * | |B|B|B|B|B|B| |D|D|D|D|D|D| | | | | | | | | | |\n * | | |C|C|C|C| | | | | | | | | | | | | | | | | | |\n * |\n * V (stack trace depth)\n *\n * ...into something ordered like below:\n *\n * [ Call A ][ Call E ]\n *\n * ...where the hierarchy of these calls can be represented as:\n *\n * [-------- Call A --------][ Call E ]\n *  [- Call B -][- Call D -]\n *   [ Call C ]\n *\n * ...and where each call has an absolute timestamp and a duration.\n *\n * Considerations:\n *\n * 1. Consecutive stack frames which cross boundaries may not be coalesced.\n * \"Boundaries\" are an array of timestamps corresponding to the begin and end\n * of certain events (such as \"RunTask\").\n *\n * For example, we expect to reformulate something like:\n *\n *   (boundary)                                    (boundary)\n *       |                                             |\n * |A|A|A|A|A|A|A|A|A|A|A|A|A|A|A|A|A| |E|E|E|E|E|E|   |\n *       |                                             |\n *\n * ...into something ordered like below:\n *\n * [ Call A ][ Call A ][ Call E ]\n *\n * ... where the first Call A is before the first boundary, second Call A is\n * after the first boundary, and Call E is inbetween boundaries.\n *\n * 2. Consecutive stack frames which are part of different branches (a.k.a part\n * of a different stack trace) must not be coalesced, even if at the same depth.\n *\n * For example, with something like:\n *\n * +------------> (sample at time)\n * |\n * | ... |X|X|X|Z|Z|Z| ...\n * |         |Y|Y|\n * |\n * V (stack trace depth)\n *\n * ...or:\n *\n * +------------> (sample at time)\n * |\n * | ... |X|X|X|Z|X|X|X| ...\n * |         |Y| |Y|\n * |\n * V (stack trace depth)\n *\n * ...the Y stack frames must not be merged even if they have been sampled\n * close together, and even if they do not cross any boundaries (e.g. are part\n * of the same `RunTask`). This is because they are either:\n * - part of separate stack traces (and therefore would have different IDs), or\n * - separated by a different parent frame.\n */\nexport function mergeCalls(calls: ProfileCall[], boundaries: Types.Timing.MicroSeconds[]): {\n  calls: ProfileCall[],\n  dur: Types.Timing.MicroSeconds,\n} {\n  const out = {calls: new Array<ProfileCall>(), dur: Types.Timing.MicroSeconds(0)};\n  let boundary = 0;\n\n  for (const call of calls) {\n    // When the call crosses a boundary defined by any of the relevant trace\n    // events (e.g. `RunTask`), even if the stack frame would be the same, start\n    // a new merge with the current call as head, and find the next boundary.\n    const isAcrossBoundary = call.ts >= boundary;\n    if (isAcrossBoundary) {\n      const index = Platform.ArrayUtilities.nearestIndexFromBeginning(boundaries, ts => ts > call.ts) ?? Infinity;\n      boundary = boundaries[index];\n      out.calls.push(call);\n      continue;\n    }\n\n    // Otherwise, start a new merge if the call is a different stack frame, or\n    // it was sampled too far into the future from the previous call.\n    const previous = out.calls.at(-1);\n    if (!previous) {\n      continue;\n    }\n    const isSameStackFrame = call.stackFrame.nodeId === previous.stackFrame.nodeId;\n    const isSampledConsecutively = call.ts - (previous.ts + previous.dur) < SAMPLING_INTERVAL;\n    if (!isSameStackFrame || !isSampledConsecutively) {\n      out.calls.push(call);\n      continue;\n    }\n\n    previous.dur = Types.Timing.MicroSeconds(call.ts - previous.ts);\n    previous.children.push(...call.children);\n  }\n\n  for (const call of out.calls) {\n    const merge = mergeCalls(call.children, boundaries);\n    call.children = merge.calls;\n    call.selfDur = Types.Timing.MicroSeconds(call.dur - merge.dur);\n    out.dur = Types.Timing.MicroSeconds(out.dur + call.dur);\n  }\n\n  return out;\n}\n\n/**\n * Checks if the call frame is allowed (i.e. it may not be part of the collected\n * stack traces tree).\n */\nexport function isAllowedCallFrame(\n    callFrame: Types.TraceEvents.TraceEventCallFrame,\n    options?: {filterCodeTypes: boolean, filterUrls: boolean}): boolean {\n  if (options?.filterCodeTypes && !ALLOWED_CALL_FRAME_CODE_TYPES.has(callFrame.codeType)) {\n    return false;\n  }\n  if (options?.filterUrls && BANNED_CALL_FRAME_URL_REGS.some(re => callFrame.url?.match(re))) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Walks the stack traces tree from top to bottom until it finds a call frame that is allowed.\n */\nexport function findTopmostAllowedCallFrame(\n    nodeId: Types.TraceEvents.CallFrameID|null, tree: ProfileTree,\n    options?: {filterCodeTypes: boolean, filterUrls: boolean}): Types.TraceEvents.CallFrameID|null {\n  if (nodeId === null) {\n    return null;\n  }\n  const node = tree.nodes.get(nodeId);\n  const callFrame = node?.callFrame;\n  if (!node || !callFrame) {\n    return null;\n  }\n  if (!isAllowedCallFrame(callFrame, options)) {\n    return findTopmostAllowedCallFrame(node.parentId, tree, options);\n  }\n  return nodeId;\n}\n\n/**\n * Gets the stack trace associated with a sample. The topmost stack frame will\n * be the last entry of array. Aka the root stack frame will be the first.\n *\n * All the complete stack traces are stored as part of a profile tree. All the\n * samples point to the topmost stack frame. This method walks up the tree to\n * compose a stack trace.\n */\nexport function buildStackTraceAsCallFrameIdsFromId(\n    tree: ProfileTree, nodeId: Types.TraceEvents.CallFrameID): Types.TraceEvents.CallFrameID[] {\n  const out = [];\n\n  let currentNodeId: Types.TraceEvents.CallFrameID|null = nodeId;\n  let currentNode;\n\n  while (currentNodeId !== null && (currentNode = tree.nodes.get(currentNodeId))) {\n    out.push(currentNodeId);\n    currentNodeId = currentNode.parentId;\n  }\n\n  return out.reverse();\n}\n\n/**\n * Just like `buildStackTrace`, but returns an array of call frames instead of ids.\n */\nexport function buildStackTraceAsCallFramesFromId(\n    tree: ProfileTree, nodeId: Types.TraceEvents.CallFrameID): Types.TraceEvents.TraceEventCallFrame[] {\n  const trace = buildStackTraceAsCallFrameIdsFromId(tree, nodeId);\n  return trace.map(nodeId => {\n    const callFrame = tree.nodes.get(nodeId)?.callFrame;\n    if (!callFrame) {\n      throw new Error();\n    }\n    return callFrame;\n  });\n}\n\n/**\n * Just like `buildStackTrace`, but returns a `ProfileCall` instead of an array.\n */\nexport function buildProfileCallFromSample(tree: ProfileTree, sample: ProfileSample): ProfileCall {\n  const trace = buildStackTraceAsCallFrameIdsFromId(tree, sample.topmostStackFrame.nodeId);\n  const calls = trace.map(nodeId => makeProfileCall(nodeId, sample));\n\n  for (let i = 1; i < calls.length; i++) {\n    const parent = calls[i - 1];\n    const current = calls[i];\n    parent.children.push(current);\n  }\n\n  return calls[0];\n}\n\n/**\n * Gets all functions that have been called between the given timestamps, each\n * with additional information:\n * - the call frame id, which points to a node containing the function name etc.\n * - all individual calls for that function\n * - percentage of time taken, relative to the given timestamps\n * - percentage of self time taken relative to the given timestamps\n */\nexport function getAllFunctionsBetweenTimestamps(\n    calls: ProfileCall[], begin: Types.Timing.MicroSeconds, end: Types.Timing.MicroSeconds,\n    out: Map<Types.TraceEvents.CallFrameID, ProfileFunction> = new Map()): IterableIterator<ProfileFunction> {\n  for (const call of calls) {\n    if (call.ts < begin || call.ts + call.dur > end) {\n      continue;\n    }\n    const func = Platform.MapUtilities.getWithDefault(\n        out, call.stackFrame.nodeId, () => makeEmptyProfileFunction(call.stackFrame.nodeId));\n    func.calls.push(call);\n    func.durPercent += (call.dur / (end - begin)) * 100;\n    func.selfDurPercent += (call.selfDur / (end - begin)) * 100;\n    getAllFunctionsBetweenTimestamps(call.children, begin, end, out);\n  }\n\n  return out.values();\n}\n\n/**\n * Gets all the hot functions between timestamps, each with information about\n * the relevant call frame, time, self time, and percentages.\n *\n * The hot functions are sorted by self time.\n */\nexport function getAllHotFunctionsBetweenTimestamps(\n    calls: ProfileCall[], begin: Types.Timing.MicroSeconds, end: Types.Timing.MicroSeconds,\n    minSelfPercent: number): ProfileFunction[] {\n  const functions = getAllFunctionsBetweenTimestamps(calls, begin, end);\n  const hot = [...functions].filter(info => info.selfDurPercent >= minSelfPercent);\n  return hot.sort((a, b) => a.selfDurPercent > b.selfDurPercent ? -1 : 1);\n}\n\nexport interface SamplesHandlerData {\n  profiles: Map<Types.TraceEvents.ProfileID, Partial<SamplesProfile>>;\n  processes: Map<Types.TraceEvents.ProcessID, SamplesProcess>;\n}\n\nexport interface SamplesProfile {\n  head: Types.TraceEvents.TraceEventProfile;\n  chunks: Types.TraceEvents.TraceEventProfileChunk[];\n}\n\nexport interface SamplesProcess {\n  threads: Map<Types.TraceEvents.ThreadID, SamplesThread>;\n}\n\nexport interface SamplesThread {\n  profile: SamplesProfile;\n  boundaries?: Types.Timing.MicroSeconds[];\n  tree?: ProfileTree;\n  samples?: ProfileSample[];\n  calls?: ProfileCall[];\n  dur?: Types.Timing.MicroSeconds;\n}\n\nexport interface ProfileTree {\n  nodes: Map<Types.TraceEvents.CallFrameID, ProfileNode>;\n}\n\nexport interface ProfileNode {\n  callFrame: Types.TraceEvents.TraceEventCallFrame;\n  parentId: Types.TraceEvents.CallFrameID|null;\n  childrenIds: Set<Types.TraceEvents.CallFrameID>;\n}\n\nexport interface ProfileSample {\n  topmostStackFrame: {\n    nodeId: Types.TraceEvents.CallFrameID,\n  };\n  pid: Types.TraceEvents.ProcessID;\n  tid: Types.TraceEvents.ThreadID;\n  ts: Types.Timing.MicroSeconds;\n}\n\nexport interface ProfileCall {\n  stackFrame: {\n    nodeId: Types.TraceEvents.CallFrameID,\n  };\n  pid: Types.TraceEvents.ProcessID;\n  tid: Types.TraceEvents.ThreadID;\n  ts: Types.Timing.MicroSeconds;\n  dur: Types.Timing.MicroSeconds;      // \"time\"\n  selfDur: Types.Timing.MicroSeconds;  // \"self time\"\n  children: ProfileCall[];\n}\n\nexport interface ProfileFunction {\n  stackFrame: {\n    nodeId: Types.TraceEvents.CallFrameID,\n  };\n  calls: ProfileCall[];\n  durPercent: number;      // 0 - 100\n  selfDurPercent: number;  // 0 - 100\n}\n"]}