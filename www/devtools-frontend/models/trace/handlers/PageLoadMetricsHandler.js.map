{"version":3,"file":"PageLoadMetricsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/PageLoadMetricsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * This handler stores page load metrics, including web vitals,\n * and exports them in the shape of a map with the following shape:\n * Map(FrameId -> Map(navigationID -> metrics) )\n *\n * It also exports all markers in a trace in an array.\n *\n * Some metrics are taken directly from a page load events (AKA markers) like DCL.\n * Others require processing multiple events to be determined, like CLS and TBT.\n */\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\n\nimport {type TraceEventHandlerName, type EnabledHandlerDataWithMeta, type Handlers} from './types.js';\n\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\n\n/**\n * This represents the metric scores for all navigations, for all frames in a trace.\n * Given a frame id, the map points to another map from navigation id to metric scores.\n * The metric scores include the event related to the metric as well as the data regarding\n * the score itself.\n */\nconst metricScoresByFrameId =\n    new Map</* Frame id */ string, Map</* navigation id */ string, Map<MetricName, MetricScore>>>();\n\n/**\n * Page load events with no associated duration that happened in the\n * main frame.\n */\nlet allMarkerEvents: Types.TraceEvents.PageLoadEvent[] = [];\n\nexport function reset(): void {\n  metricScoresByFrameId.clear();\n  pageLoadEventsArray = [];\n  allMarkerEvents = [];\n  selectedLCPCandidateEvents.clear();\n}\n\nlet pageLoadEventsArray: Types.TraceEvents.PageLoadEvent[] = [];\n\n// Once we've found the LCP events in the trace we want to fetch their DOM Node\n// from the backend. We could do this by parsing through our Map of frame =>\n// navigation => metric, but it's easier to keep a set of LCP events. As we\n// parse the trace, any time we store an LCP candidate as the potential LCP\n// event, we store the event here. If we later find a new candidate in the\n// trace, we store that and delete the prior event. When we've parsed the\n// entire trace this set will contain all the LCP events that were used - e.g.\n// the candidates that were the actual LCP events.\nconst selectedLCPCandidateEvents = new Set<Types.TraceEvents.TraceEventLargestContentfulPaintCandidate>();\n\nexport const MarkerName =\n    ['MarkDOMContent', 'MarkLoad', 'firstPaint', 'firstContentfulPaint', 'largestContentfulPaint::Candidate'] as const;\n\nconst markerTypeGuards = [\n  Types.TraceEvents.isTraceEventMarkDOMContent,\n  Types.TraceEvents.isTraceEventMarkLoad,\n  Types.TraceEvents.isTraceEventFirstPaint,\n  Types.TraceEvents.isTraceEventFirstContentfulPaint,\n  Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate,\n];\n\ninterface MakerEvent extends Types.TraceEvents.TraceEventData {\n  name: typeof MarkerName[number];\n}\n\nexport function isTraceEventMarkerEvent(event: Types.TraceEvents.TraceEventData): event is MakerEvent {\n  return markerTypeGuards.some(fn => fn(event));\n}\n\nconst pageLoadEventTypeGuards = [\n  ...markerTypeGuards,\n  Types.TraceEvents.isTraceEventInteractiveTime,\n];\n\nexport function eventIsPageLoadEvent(event: Types.TraceEvents.TraceEventData):\n    event is Types.TraceEvents.PageLoadEvent {\n  return pageLoadEventTypeGuards.some(fn => fn(event));\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (!eventIsPageLoadEvent(event)) {\n    return;\n  }\n  pageLoadEventsArray.push(event);\n}\n\nfunction storePageLoadMetricAgainstNavigationId(\n    navigation: Types.TraceEvents.TraceEventNavigationStart, event: Types.TraceEvents.PageLoadEvent): void {\n  const navigationId = navigation.args.data?.navigationId;\n  if (!navigationId) {\n    throw new Error('Navigation event unexpectedly had no navigation ID.');\n  }\n  const frameId = getFrameIdForPageLoadEvent(event);\n  const {rendererProcessesByFrame} = metaHandlerData();\n\n  // If either of these pieces of data do not exist, the most likely\n  // explanation is that the page load metric we found is for a frame/process\n  // combo that the MetaHandler discarded. This typically happens if we get a\n  // navigation event with an empty URL. Therefore, we will silently return and\n  // drop this metric. If we didn't care about the navigation, we certainly do\n  // not need to care about metrics for that navigation.\n  const rendererProcessesInFrame = rendererProcessesByFrame.get(frameId);\n  if (!rendererProcessesInFrame) {\n    return;\n  }\n  const processData = rendererProcessesInFrame.get(event.pid);\n  if (!processData) {\n    return;\n  }\n\n  // We compare the timestamp of the event to determine if it happened during the\n  // time window in which its process was considered active.\n  const eventBelongsToProcess = event.ts >= processData.window.min && event.ts <= processData.window.max;\n\n  if (!eventBelongsToProcess) {\n    // If the event occurred outside its process' active time window we ignore it.\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventFirstContentfulPaint(event)) {\n    const fcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const score = Helpers.Timing.formatMicrosecondsTime(fcpTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const classification = scoreClassificationForFirstContentfulPaint(fcpTime);\n    const metricScore = {event, score, metricName: MetricName.FCP, classification, navigation};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventFirstPaint(event)) {\n    const paintTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const score = Helpers.Timing.formatMicrosecondsTime(paintTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const classification = ScoreClassification.UNCLASSIFIED;\n    const metricScore = {event, score, metricName: MetricName.FP, classification, navigation};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventMarkDOMContent(event)) {\n    const dclTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const score = Helpers.Timing.formatMicrosecondsTime(dclTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const metricScore = {\n      event,\n      score,\n      metricName: MetricName.DCL,\n      classification: scoreClassificationForDOMContentLoaded(dclTime),\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventInteractiveTime(event)) {\n    const ttiValue = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const ttiScore = Helpers.Timing.formatMicrosecondsTime(ttiValue, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const tti = {\n      event,\n      score: ttiScore,\n      metricName: MetricName.TTI,\n      classification: scoreClassificationForTimeToInteractive(ttiValue),\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, tti);\n\n    const tbtValue =\n        Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(event.args.args.total_blocking_time_ms));\n    const tbtScore = Helpers.Timing.formatMicrosecondsTime(tbtValue, {\n      format: Types.Timing.TimeUnit.MILLISECONDS,\n      maximumFractionDigits: 2,\n    });\n    const tbt = {\n      event,\n      score: tbtScore,\n      metricName: MetricName.TBT,\n      classification: scoreClassificationForTotalBlockingTime(tbtValue),\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, tbt);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventMarkLoad(event)) {\n    const loadTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const score = Helpers.Timing.formatMicrosecondsTime(loadTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const metricScore = {\n      event,\n      score,\n      metricName: MetricName.L,\n      classification: ScoreClassification.UNCLASSIFIED,\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event)) {\n    const candidateIndex = event.args.data?.candidateIndex;\n    if (!candidateIndex) {\n      throw new Error('Largest Contenful Paint unexpectedly had no candidateIndex.');\n    }\n    const lcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const lcpScore = Helpers.Timing.formatMicrosecondsTime(lcpTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const lcp = {\n      event,\n      score: lcpScore,\n      metricName: MetricName.LCP,\n      classification: scoreClassificationForLargestContentfulPaint(lcpTime),\n      navigation,\n    };\n    const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n    const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n    const lastLCPCandidate = metrics.get(MetricName.LCP);\n    if (lastLCPCandidate === undefined) {\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n      return;\n    }\n    const lastLCPCandidateEvent = lastLCPCandidate.event;\n\n    if (!Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(lastLCPCandidateEvent)) {\n      return;\n    }\n    const lastCandidateIndex = lastLCPCandidateEvent.args.data?.candidateIndex;\n    if (!lastCandidateIndex) {\n      // lastCandidateIndex cannot be undefined because we don't store candidates with\n      // with an undefined candidateIndex value. This check is only to make TypeScript\n      // treat the field as not undefined below.\n      return;\n    }\n    if (lastCandidateIndex < candidateIndex) {\n      selectedLCPCandidateEvents.delete(lastLCPCandidateEvent);\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n    }\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventLayoutShift(event)) {\n    return;\n  }\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction storeMetricScore(frameId: string, navigationId: string, metricScore: MetricScore): void {\n  const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n  const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n  // If an entry with that metric name is present, delete it so that the new entry that\n  // will replace it is added at the end of the map. This way we guarantee the map entries\n  // are ordered in ASC manner by timestamp.\n  metrics.delete(metricScore.metricName);\n  metrics.set(metricScore.metricName, metricScore);\n}\n\nexport function getFrameIdForPageLoadEvent(event: Types.TraceEvents.PageLoadEvent): string {\n  if (Types.TraceEvents.isTraceEventFirstContentfulPaint(event) ||\n      Types.TraceEvents.isTraceEventInteractiveTime(event) ||\n      Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event) ||\n      Types.TraceEvents.isTraceEventLayoutShift(event) || Types.TraceEvents.isTraceEventFirstPaint(event)) {\n    return event.args.frame;\n  }\n  if (Types.TraceEvents.isTraceEventMarkDOMContent(event) || Types.TraceEvents.isTraceEventMarkLoad(event)) {\n    const frameId = event.args.data?.frame;\n    if (!frameId) {\n      throw new Error('MarkDOMContent unexpectedly had no frame ID.');\n    }\n    return frameId;\n  }\n  Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction getNavigationForPageLoadEvent(event: Types.TraceEvents.PageLoadEvent):\n    Types.TraceEvents.TraceEventNavigationStart|null {\n  if (Types.TraceEvents.isTraceEventFirstContentfulPaint(event) ||\n      Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event) ||\n      Types.TraceEvents.isTraceEventFirstPaint(event)) {\n    const navigationId = event.args.data?.navigationId;\n    if (!navigationId) {\n      throw new Error('Trace event unexpectedly had no navigation ID.');\n    }\n    const {navigationsByNavigationId} = metaHandlerData();\n    const navigation = navigationsByNavigationId.get(navigationId);\n\n    if (!navigation) {\n      // This event's navigation has been filtered out by the meta handler as a noise event.\n      return null;\n    }\n    return navigation;\n  }\n\n  if (Types.TraceEvents.isTraceEventMarkDOMContent(event) || Types.TraceEvents.isTraceEventInteractiveTime(event) ||\n      Types.TraceEvents.isTraceEventLayoutShift(event) || Types.TraceEvents.isTraceEventMarkLoad(event)) {\n    const frameId = getFrameIdForPageLoadEvent(event);\n    const {navigationsByFrameId} = metaHandlerData();\n    return Helpers.Trace.getNavigationForTraceEvent(event, frameId, navigationsByFrameId);\n  }\n\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\n/*\n * When we first load a new trace, rather than position the playhead at time 0,\n* we want to position it such that the thumbnail likely shows something rather\n* than a blank white page, and so that it's positioned somewhere that's useful\n* for the user.  This function takes the model data, and returns either the\n* timestamp of the first FCP event, or null if it couldn't find one.\n */\nexport function getFirstFCPTimestampFromModelData(model: EnabledHandlerDataWithMeta<Handlers>):\n    Types.Timing.MicroSeconds|null {\n  const mainFrameID = model.Meta.mainFrameId;\n  const metricsForMainFrameByNavigationID = model.PageLoadMetrics.metricScoresByFrameId.get(mainFrameID);\n  if (!metricsForMainFrameByNavigationID) {\n    return null;\n  }\n\n  // Now find the first FCP event by timestamp. Events may not have the raw\n  // data including timestamp, and if so we skip that event.\n  let firstFCPEventInTimeline: Types.Timing.MicroSeconds|null = null;\n  for (const metrics of metricsForMainFrameByNavigationID.values()) {\n    const fcpMetric = metrics.get(MetricName.FCP);\n    const fcpTimestamp = fcpMetric?.event?.ts;\n    if (fcpTimestamp) {\n      if (!firstFCPEventInTimeline) {\n        firstFCPEventInTimeline = fcpTimestamp;\n      } else if (fcpTimestamp < firstFCPEventInTimeline) {\n        firstFCPEventInTimeline = fcpTimestamp;\n      }\n    }\n  }\n  return firstFCPEventInTimeline;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/fcp/\n */\n\nexport function scoreClassificationForFirstContentfulPaint(fcpScoreInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const FCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(1.8));\n  const FCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.0));\n  let scoreClassification = ScoreClassification.BAD;\n  if (fcpScoreInMicroseconds <= FCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (fcpScoreInMicroseconds <= FCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/interactive/#how-lighthouse-determines-your-tti-score\n */\n\nexport function scoreClassificationForTimeToInteractive(ttiTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const TTI_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.8));\n  const TTI_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(7.3));\n  let scoreClassification = ScoreClassification.BAD;\n  if (ttiTimeInMicroseconds <= TTI_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (ttiTimeInMicroseconds <= TTI_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lcp/#what-is-lcp\n */\n\nexport function scoreClassificationForLargestContentfulPaint(lcpTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const LCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(2.5));\n  const LCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(4));\n  let scoreClassification = ScoreClassification.BAD;\n  if (lcpTimeInMicroseconds <= LCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (lcpTimeInMicroseconds <= LCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * DCL does not have a classification.\n */\nexport function scoreClassificationForDOMContentLoaded(_dclTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  return ScoreClassification.UNCLASSIFIED;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lighthouse-total-blocking-#time/\n */\n\nexport function scoreClassificationForTotalBlockingTime(tbtTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const TBT_GOOD_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(200));\n  const TBT_MEDIUM_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(600));\n  let scoreClassification = ScoreClassification.BAD;\n  if (tbtTimeInMicroseconds <= TBT_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (tbtTimeInMicroseconds <= TBT_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Gets all the Largest Contentful Paint scores of all the frames in the\n * trace.\n */\nfunction gatherFinalLCPEvents(): Types.TraceEvents.PageLoadEvent[] {\n  const allFinalLCPEvents: Types.TraceEvents.PageLoadEvent[] = [];\n  const dataForAllFrames = [...metricScoresByFrameId.values()];\n  const dataForAllNavigations = dataForAllFrames.flatMap(frameData => [...frameData.values()]);\n  for (let i = 0; i < dataForAllNavigations.length; i++) {\n    const navigationData = dataForAllNavigations[i];\n    const lcpInNavigation = navigationData.get(MetricName.LCP);\n    if (!lcpInNavigation || !lcpInNavigation.event) {\n      continue;\n    }\n\n    allFinalLCPEvents.push(lcpInNavigation.event);\n  }\n  return allFinalLCPEvents;\n}\n\nexport async function finalize(): Promise<void> {\n  pageLoadEventsArray.sort((a, b) => a.ts - b.ts);\n\n  for (const pageLoadEvent of pageLoadEventsArray) {\n    const navigation = getNavigationForPageLoadEvent(pageLoadEvent);\n    if (navigation) {\n      // Event's navigation was not filtered out as noise.\n      storePageLoadMetricAgainstNavigationId(navigation, pageLoadEvent);\n    }\n  }\n  // NOTE: if you are looking for the TBT calculation, it has temporarily been\n  // removed. See crbug.com/1424335 for details.\n  const allFinalLCPEvents = gatherFinalLCPEvents();\n  const mainFrame = metaHandlerData().mainFrameId;\n  // Filter out LCP candidates to use only definitive LCP values\n  const allEventsButLCP =\n      pageLoadEventsArray.filter(event => !Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event));\n  const markerEvents = [...allFinalLCPEvents, ...allEventsButLCP].filter(isTraceEventMarkerEvent);\n  // Filter by main frame and sort.\n  allMarkerEvents =\n      markerEvents.filter(event => getFrameIdForPageLoadEvent(event) === mainFrame).sort((a, b) => a.ts - b.ts);\n}\n\nexport type PageLoadMetricsData = {\n  metricScoresByFrameId: Map<string, Map<string, Map<MetricName, MetricScore>>>,\n  allMarkerEvents: Types.TraceEvents.PageLoadEvent[],\n};\n\nexport function data(): PageLoadMetricsData {\n  return {\n    /**\n     * This represents the metric scores for all navigations, for all frames in a trace.\n     * Given a frame id, the map points to another map from navigation id to metric scores.\n     * The metric scores include the event related to the metric as well as the data regarding\n     * the score itself.\n     */\n    metricScoresByFrameId: new Map(metricScoresByFrameId),\n\n    /**\n     * Page load events with no associated duration that happened in the\n     * main frame.\n     */\n    allMarkerEvents: [...allMarkerEvents],\n  };\n}\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Meta'];\n}\n\nexport const enum ScoreClassification {\n  GOOD = 'good',\n  OK = 'ok',\n  BAD = 'bad',\n  // Some metrics (such as DOMContentLoaded) don't have a Good/OK/Bad classification, hence this additional entry.\n  UNCLASSIFIED = 'unclassified',\n}\n\nexport const enum MetricName {\n  // First Contentful Paint\n  FCP = 'FCP',\n  // First Paint\n  FP = 'FP',\n  // MarkLoad\n  L = 'L',\n  LCP = 'LCP',\n  // Mark DOM Content\n  DCL = 'DCL',\n  // Time To Interactive\n  TTI = 'TTI',\n  // Total Blocking Time\n  TBT = 'TBT',\n  // Cumulative Layout Shift\n  CLS = 'CLS',\n}\n\nexport interface MetricScore {\n  score: string;\n  metricName: MetricName;\n  classification: ScoreClassification;\n  event?: Types.TraceEvents.PageLoadEvent;\n  // The last navigation that occured before this metric score.\n  navigation?: Types.TraceEvents.TraceEventNavigationStart;\n  estimated?: boolean;\n}\n"]}