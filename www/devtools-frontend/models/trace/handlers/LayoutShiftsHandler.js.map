{"version":3,"file":"LayoutShiftsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/LayoutShiftsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\n\nimport {type TraceEventHandlerName, HandlerState} from './types.js';\n\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {data as screenshotsHandlerData} from './ScreenshotsHandler.js';\nimport * as Platform from '../../../core/platform/platform.js';\n\nimport * as Types from '../types/types.js';\n\n// We start with a score of zero and step through all Layout Shift records from\n// all renderers. Each record not only tells us which renderer it is, but also\n// the unweighted and weighted scores. The unweighted score is the score we would\n// get if the renderer were the only one in the viewport. The weighted score, on\n// the other hand, accounts for how much of the viewport that particular render\n// takes up when the shift happened. An ad frame in the corner of the viewport\n// that shifts is considered less disruptive, therefore, than if it were taking\n// up the whole viewport.\n//\n// Next, we step through all the records from all renderers and add the weighted\n// score to a running total across all of the renderers. We create a new \"cluster\"\n// and reset the running total when:\n//\n// 1. We observe a outermost frame navigation, or\n// 2. When there's a gap between records of > 1s, or\n// 3. When there's more than 5 seconds of continuous layout shifting.\n//\n// Note that for it to be Cumulative Layout Shift in the sense described in the\n// documentation we would need to guarantee that we are tracking from navigation\n// to unload. However, we don't make any such guarantees here (since a developer\n// can record and stop when they please), so we support the cluster approach,\n// and we can give them a score, but it is effectively a \"session\" score, a\n// score for the given recording, and almost certainly not the\n// navigation-to-unload CLS score.\n\ninterface LayoutShifts {\n  clusters: LayoutShiftCluster[];\n  sessionMaxScore: number;\n  // The session window which contains the SessionMaxScore\n  clsWindowID: number;\n  // We use these to calculate root causes for a given LayoutShift\n  prePaintEvents: Types.TraceEvents.TraceEventPrePaint[];\n  layoutInvalidationEvents: Types.TraceEvents.TraceEventLayoutInvalidation[];\n  styleRecalcInvalidationEvents: Types.TraceEvents.TraceEventStyleRecalcInvalidation[];\n  scoreRecords: ScoreRecord[];\n}\n\n// This represents the maximum #time we will allow a cluster to go before we\n// reset it.\nexport const MAX_CLUSTER_DURATION = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(5000));\n\n// This represents the maximum #time we will allow between layout shift events\n// before considering it to be the start of a new cluster.\nexport const MAX_SHIFT_TIME_DELTA = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(1000));\n\n// Layout shifts are reported globally to the developer, irrespective of which\n// frame they originated in. However, each process does have its own individual\n// CLS score, so we need to segment by process. This means Layout Shifts from\n// sites with one process (no subframes, or subframes from the same origin)\n// will be reported together. In the case of multiple renderers (frames across\n// different origins), we offer the developer the ability to switch renderer in\n// the UI.\nconst layoutShiftEvents: Types.TraceEvents.TraceEventLayoutShift[] = [];\n\n// These events denote potential node resizings. We store them to link captured\n// layout shifts to the resizing of unsized elements.\nconst layoutInvalidationEvents: Types.TraceEvents.TraceEventLayoutInvalidation[] = [];\nconst styleRecalcInvalidationEvents: Types.TraceEvents.TraceEventStyleRecalcInvalidation[] = [];\n\n// Layout shifts happen during PrePaint as part of the rendering lifecycle.\n// We determine if a LayoutInvalidation event is a potential root cause of a layout\n// shift if the next PrePaint after the LayoutInvalidation is the parent\n// node of such shift.\nconst prePaintEvents: Types.TraceEvents.TraceEventPrePaint[] = [];\n\nlet sessionMaxScore = 0;\n\nlet clsWindowID = -1;\n\nconst clusters: LayoutShiftCluster[] = [];\n\n// Represents a point in time in which a  LS score change\n// was recorded.\ntype ScoreRecord = {\n  ts: number,\n  score: number,\n};\n\n// The complete timeline of LS score changes in a trace.\n// Includes drops to 0 when session windows end.\nconst scoreRecords: ScoreRecord[] = [];\n\nlet handlerState = HandlerState.UNINITIALIZED;\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('LayoutShifts Handler was not reset');\n  }\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function reset(): void {\n  handlerState = HandlerState.UNINITIALIZED;\n  layoutShiftEvents.length = 0;\n  layoutInvalidationEvents.length = 0;\n  prePaintEvents.length = 0;\n  clusters.length = 0;\n  sessionMaxScore = 0;\n  scoreRecords.length = 0;\n  clsWindowID = -1;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isTraceEventLayoutShift(event) && !event.args.data?.had_recent_input) {\n    layoutShiftEvents.push(event);\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventLayoutInvalidation(event)) {\n    layoutInvalidationEvents.push(event);\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventStyleRecalcInvalidation(event)) {\n    styleRecalcInvalidationEvents.push(event);\n  }\n  if (Types.TraceEvents.isTraceEventPrePaint(event)) {\n    prePaintEvents.push(event);\n    return;\n  }\n}\n\nfunction traceWindowFromTime(time: Types.Timing.MicroSeconds): Types.Timing.TraceWindow {\n  return {\n    min: time,\n    max: time,\n    range: Types.Timing.MicroSeconds(0),\n  };\n}\n\nfunction updateTraceWindowMax(traceWindow: Types.Timing.TraceWindow, newMax: Types.Timing.MicroSeconds): void {\n  traceWindow.max = newMax;\n  traceWindow.range = Types.Timing.MicroSeconds(traceWindow.max - traceWindow.min);\n}\n\nfunction findNextScreenshotSource(timestamp: Types.Timing.MicroSeconds): string|undefined {\n  const screenshots = screenshotsHandlerData();\n  const screenshotIndex = findNextScreenshotEventIndex(screenshots, timestamp);\n  if (!screenshotIndex) {\n    return undefined;\n  }\n  return `data:img/png;base64,${screenshots[screenshotIndex].args.snapshot}`;\n}\n\nexport function findNextScreenshotEventIndex(\n    screenshots: Types.TraceEvents.TraceEventSnapshot[], timestamp: Types.Timing.MicroSeconds): number|null {\n  return Platform.ArrayUtilities.nearestIndexFromBeginning(screenshots, frame => frame.ts > timestamp);\n}\n\nfunction buildScoreRecords(): void {\n  const {traceBounds} = metaHandlerData();\n  scoreRecords.push({ts: traceBounds.min, score: 0});\n\n  for (const cluster of clusters) {\n    let clusterScore = 0;\n    if (cluster.events[0].args.data) {\n      scoreRecords.push({ts: cluster.clusterWindow.min, score: cluster.events[0].args.data.weighted_score_delta});\n    }\n    for (let i = 0; i < cluster.events.length; i++) {\n      const event = cluster.events[i];\n      if (!event.args.data) {\n        continue;\n      }\n      clusterScore += event.args.data.weighted_score_delta;\n      scoreRecords.push({ts: event.ts, score: clusterScore});\n    }\n    scoreRecords.push({ts: cluster.clusterWindow.max, score: 0});\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // Ensure the events are sorted by #time ascending.\n  layoutShiftEvents.sort((a, b) => a.ts - b.ts);\n  prePaintEvents.sort((a, b) => a.ts - b.ts);\n  layoutInvalidationEvents.sort((a, b) => a.ts - b.ts);\n\n  // Each function transforms the data used by the next, as such the invoke order\n  // is important.\n  await buildLayoutShiftsClusters();\n  buildScoreRecords();\n  handlerState = HandlerState.FINALIZED;\n}\nasync function buildLayoutShiftsClusters(): Promise<void> {\n  const {navigationsByFrameId, mainFrameId, traceBounds} = metaHandlerData();\n  const navigations = navigationsByFrameId.get(mainFrameId) || [];\n  if (layoutShiftEvents.length === 0) {\n    return;\n  }\n  let firstShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftNavigation = null;\n  // Now step through each and create clusters.\n  // A cluster is equivalent to a session window (see https://web.dev/cls/#what-is-cls).\n  // To make the line chart clear, we explicitly demark the limits of each session window\n  // by starting the cumulative score of the window at the time of the first layout shift\n  // and ending it (dropping the line back to 0) when the window ends according to the\n  // thresholds (MAX_CLUSTER_DURATION, MAX_SHIFT_TIME_DELTA).\n  for (const event of layoutShiftEvents) {\n    // First detect if either the cluster duration or the #time between this and\n    // the last shift has been exceeded.\n    const clusterDurationExceeded = event.ts - firstShiftTime > MAX_CLUSTER_DURATION;\n    const maxTimeDeltaSinceLastShiftExceeded = event.ts - lastShiftTime > MAX_SHIFT_TIME_DELTA;\n\n    // Next take a look at navigations. If between this and the last shift we have navigated,\n    // note it.\n    const currentShiftNavigation = Platform.ArrayUtilities.nearestIndexFromEnd(navigations, nav => nav.ts < event.ts);\n    const hasNavigated = lastShiftNavigation !== currentShiftNavigation && currentShiftNavigation !== null;\n\n    // If any of the above criteria are met or if we don't have any cluster yet we should\n    // start a new one.\n    if (clusterDurationExceeded || maxTimeDeltaSinceLastShiftExceeded || hasNavigated || !clusters.length) {\n      // The cluster starts #time should be the timestamp of the first layout shift in it.\n      const clusterStartTime = event.ts;\n\n      // If the last session window ended because the max delta time between shifts\n      // was exceeded set the endtime to MAX_SHIFT_TIME_DELTA microseconds after the\n      // last shift in the session.\n      const endTimeByMaxSessionDuration = clusterDurationExceeded ? firstShiftTime + MAX_CLUSTER_DURATION : Infinity;\n\n      // If the last session window ended because the max session duration was\n      // surpassed, set the endtime so that the window length = MAX_CLUSTER_DURATION;\n      const endTimeByMaxShiftGap = maxTimeDeltaSinceLastShiftExceeded ? lastShiftTime + MAX_SHIFT_TIME_DELTA : Infinity;\n\n      // If there was a navigation during the last window, close it at the time\n      // of the navigation.\n      const endTimeByNavigation = hasNavigated ? navigations[currentShiftNavigation].ts : Infinity;\n\n      // End the previous cluster at the time of the first of the criteria above that was met.\n      const previousClusterEndTime = Math.min(endTimeByMaxSessionDuration, endTimeByMaxShiftGap, endTimeByNavigation);\n\n      // If there is an existing cluster update its closing time.\n      if (clusters.length > 0) {\n        const currentCluster = clusters[clusters.length - 1];\n        updateTraceWindowMax(currentCluster.clusterWindow, Types.Timing.MicroSeconds(previousClusterEndTime));\n      }\n\n      clusters.push({\n        events: [],\n        clusterWindow: traceWindowFromTime(clusterStartTime),\n        clusterCumulativeScore: 0,\n        scoreWindows: {\n          good: traceWindowFromTime(clusterStartTime),\n          needsImprovement: null,\n          bad: null,\n        },\n      });\n\n      firstShiftTime = clusterStartTime;\n    }\n\n    // Given the above we should have a cluster available, so pick the most\n    // recent one and append the shift, bump its score and window values accordingly.\n    const currentCluster = clusters[clusters.length - 1];\n    const timeFromNavigation = currentShiftNavigation !== null ?\n        Types.Timing.MicroSeconds(event.ts - navigations[currentShiftNavigation].ts) :\n        undefined;\n\n    currentCluster.clusterCumulativeScore += event.args.data ? event.args.data.weighted_score_delta : 0;\n    if (!event.args.data) {\n      continue;\n    }\n    const shift: Types.TraceEvents.SyntheticLayoutShift = {\n      ...event,\n      args: {\n        frame: event.args.frame,\n        data: {\n          ...event.args.data,\n          rawEvent: event,\n        },\n      },\n      parsedData: {\n        screenshotSource: findNextScreenshotSource(event.ts),\n        timeFromNavigation,\n        cumulativeWeightedScoreInWindow: currentCluster.clusterCumulativeScore,\n        // The score of the session window is temporarily set to 0 just\n        // to initialize it. Since we need to get the score of all shifts\n        // in the session window to determine its value, its definite\n        // value is set when stepping through the built clusters.\n        sessionWindowData: {cumulativeWindowScore: 0, id: clusters.length},\n      },\n    };\n    currentCluster.events.push(shift);\n    updateTraceWindowMax(currentCluster.clusterWindow, event.ts);\n\n    lastShiftTime = event.ts;\n    lastShiftNavigation = currentShiftNavigation;\n  }\n\n  // Now step through each cluster and set up the times at which the value\n  // goes from Good, to needs improvement, to Bad. Note that if there is a\n  // large jump we may go from Good to Bad without ever creating a Needs\n  // Improvement window at all.\n  for (const cluster of clusters) {\n    let weightedScore = 0;\n    let windowID = -1;\n    // If this is the last cluster update its window. The cluster duration is determined\n    // by the minimum between: time to next navigation, trace end time, time to maximum\n    // cluster duration and time to maximum gap between layout shifts.\n    if (cluster === clusters[clusters.length - 1]) {\n      const clusterEndByMaxDuration = MAX_CLUSTER_DURATION + cluster.clusterWindow.min;\n      const clusterEndByMaxGap = cluster.clusterWindow.max + MAX_SHIFT_TIME_DELTA;\n      const nextNavigationIndex =\n          Platform.ArrayUtilities.nearestIndexFromBeginning(navigations, nav => nav.ts > cluster.clusterWindow.max);\n      const nextNavigationTime = nextNavigationIndex ? navigations[nextNavigationIndex].ts : Infinity;\n      const clusterEnd = Math.min(clusterEndByMaxDuration, clusterEndByMaxGap, traceBounds.max, nextNavigationTime);\n      updateTraceWindowMax(cluster.clusterWindow, Types.Timing.MicroSeconds(clusterEnd));\n    }\n    for (const shift of cluster.events) {\n      weightedScore += shift.args.data ? shift.args.data.weighted_score_delta : 0;\n      windowID = shift.parsedData.sessionWindowData.id;\n      const ts = shift.ts;\n      // Update the the CLS score of this shift's session window now that\n      // we have it.\n      shift.parsedData.sessionWindowData.cumulativeWindowScore = cluster.clusterCumulativeScore;\n      if (weightedScore < LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n        // Expand the Good window.\n        updateTraceWindowMax(cluster.scoreWindows.good, ts);\n      } else if (\n          weightedScore >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT && weightedScore < LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.needsImprovement) {\n          // Close the Good window, and open the needs improvement window.\n          updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.MicroSeconds(ts - 1));\n          cluster.scoreWindows.needsImprovement = traceWindowFromTime(ts);\n        }\n\n        // Expand the needs improvement window.\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, ts);\n      } else if (weightedScore >= LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.bad) {\n          // We may jump from Good to Bad here, so update whichever window is open.\n          if (cluster.scoreWindows.needsImprovement) {\n            updateTraceWindowMax(cluster.scoreWindows.needsImprovement, Types.Timing.MicroSeconds(ts - 1));\n          } else {\n            updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.MicroSeconds(ts - 1));\n          }\n\n          cluster.scoreWindows.bad = traceWindowFromTime(shift.ts);\n        }\n\n        // Expand the Bad window.\n        updateTraceWindowMax(cluster.scoreWindows.bad, ts);\n      }\n\n      // At this point the windows are set by the timestamps of the events, but the\n      // next cluster begins at the timestamp of its first event. As such we now\n      // need to expand the score window to the end of the cluster, and we do so\n      // by using the Bad widow if it's there, or the NI window, or finally the\n      // Good window.\n      if (cluster.scoreWindows.bad) {\n        updateTraceWindowMax(cluster.scoreWindows.bad, cluster.clusterWindow.max);\n      } else if (cluster.scoreWindows.needsImprovement) {\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, cluster.clusterWindow.max);\n      } else {\n        updateTraceWindowMax(cluster.scoreWindows.good, cluster.clusterWindow.max);\n      }\n    }\n    if (weightedScore > sessionMaxScore) {\n      clsWindowID = windowID;\n      sessionMaxScore = weightedScore;\n    }\n  }\n}\n\nexport function data(): LayoutShifts {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Layout Shifts Handler is not finalized');\n  }\n\n  return {\n    clusters: [...clusters],\n    sessionMaxScore: sessionMaxScore,\n    clsWindowID,\n    prePaintEvents: [...prePaintEvents],\n    layoutInvalidationEvents: [...layoutInvalidationEvents],\n    styleRecalcInvalidationEvents: [],\n    scoreRecords: [...scoreRecords],\n  };\n}\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Screenshots', 'Meta'];\n}\n\nexport function stateForLayoutShiftScore(score: number): ScoreClassification {\n  let state = ScoreClassification.GOOD;\n  if (score >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n    state = ScoreClassification.OK;\n  }\n\n  if (score >= LayoutShiftsThreshold.BAD) {\n    state = ScoreClassification.BAD;\n  }\n\n  return state;\n}\n\nexport interface LayoutShiftCluster {\n  clusterWindow: Types.Timing.TraceWindow;\n  clusterCumulativeScore: number;\n  events: Types.TraceEvents.SyntheticLayoutShift[];\n  // For convenience we split apart the cluster into good, NI, and bad windows.\n  // Since a cluster may remain in the good window, we mark NI and bad as being\n  // possibly null.\n  scoreWindows: {\n    good: Types.Timing.TraceWindow,\n    needsImprovement: Types.Timing.TraceWindow|null,\n    bad: Types.Timing.TraceWindow|null,\n  };\n}\n\n// Based on https://web.dev/cls/\nexport const enum LayoutShiftsThreshold {\n  GOOD = 0,\n  NEEDS_IMPROVEMENT = 0.1,\n  BAD = 0.25,\n}\n"]}